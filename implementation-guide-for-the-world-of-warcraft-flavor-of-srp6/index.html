<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Implementation Guide for the World of Warcraft flavor of SRP6 | GTKer.com</title><style>body{font-family:Optima,Candara,Calibri,Arial,sans-serif}code{font-family:lucida console,Monaco,monospace;font-size:85%}</style><link rel=stylesheet href=https://gtker.com/sass/style.min.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/tags/>Tags</a></li><li><a href=/wow_messages/>wow_messages</a></li><li><a href=/index.xml>Atom/RSS</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Implementation Guide for the World of Warcraft flavor of SRP6</span></h1><h2 class=date>2021-07-05</h2><h4 class=date>Last edited 2023-02-13</h4></div><p class=terms>Tags: <a href=/tags/rust>Rust</a> <a href=/tags/world-of-warcraft>World of Warcraft</a> <a href=/tags/srp6>SRP6</a> <a href=/tags/wow>WoW</a> <a href=/tags/cryptography>Cryptography</a></p><nav id=TableOfContents><ul><li><a href=#srp6-overview>SRP6 Overview</a></li><li><a href=#important-knowledge-before-starting>Important Knowledge Before Starting</a><ul><li><a href=#integers>Integers</a></li><li><a href=#endianness>Endianness</a></li><li><a href=#padding>Padding</a></li><li><a href=#hashing>Hashing</a></li><li><a href=#constants>Constants</a></li><li><a href=#aliases>Aliases</a></li></ul></li><li><a href=#implementation-details>Implementation Details</a><ul><li><a href=#password-verifier>Password Verifier</a></li><li><a href=#server-public-key>Server public key</a></li><li><a href=#session-key>Session key</a></li><li><a href=#server-proof>Server proof</a></li><li><a href=#client-proof>Client proof</a></li><li><a href=#client-public-key>Client public key</a></li></ul></li><li><a href=#reconnecting>Reconnecting</a><ul><li><a href=#reconnect-proof>Reconnect proof</a></li></ul></li><li><a href=#world-packet-header-encryption>World Packet Header Encryption</a><ul><li><a href=#encryption>Encryption</a></li><li><a href=#decryption>Decryption</a></li><li><a href=#world-server-proof>World Server Proof</a></li></ul></li><li><a href=#notes-on-uppercasing-username-and-password>Notes on uppercasing username and password</a></li><li><a href=#external-resources>External Resources</a></li></ul></nav><main><p>The authentication protocol for authenticating with a World of Warcraft (WoW) server is widely available but not very well documented.
Most documentation is spread across forums or just directly links to <a href=https://tools.ietf.org/html/rfc2945>RFC2945</a>,
the 8 page, 20 year old, very broad and unspecific RFC that describes SRP6 in relatively academic terms.</p><p>The goal of this article is to be an approachable,
complete guide to implementing the protocol specifically for WoW 1.12 without requiring external references.</p><p>The article starts out by giving a high level overview of the protocol and the specifics of the WoW implementation before
giving a function-by-function implementation guide, including files for verification and examples of implementation in Rust, C++ and Elixir.</p><p>Important terms have been highlighted with <strong>bold</strong>. The exact definitions of these will come later in the article.</p><p>This article will only cover the SRP6 protocol, not the network aspects of authenticating with a client.</p><p><strong>This is not intended to be a guide for production usage. I have no cryptographic experience and essentially stumbled upon the solutions by accident.
SRP6 is also not very widely used, possibly for a reason.
Use this only for interacting with legacy World of Warcraft game clients.</strong></p><h2 id=srp6-overview>SRP6 Overview</h2><p>SRP6 is a protocol for proving that a client and server both know the same specific password without having to send it over the network.
It does this via various mathematical tricks, none of which are important to us.</p><p>When a new account is added, the server generates a random <strong>salt</strong> value and calculates
a <strong>password verifier</strong> before saving the <strong>username</strong>, <strong>salt</strong> and <strong>password verifier</strong> to the database.</p><p>When authenticating, the protocol works in 5 different stages:</p><ol><li>The client sends their <strong>username</strong> to the server.</li><li>The server retrieves the <strong>password verifier</strong> and <strong>salt</strong> from the database, then it randomly generates
a <strong>private key</strong> which it uses to calculate a <strong>public key</strong>. It then sends the <strong>public key</strong> and <strong>salt</strong> to the client,
as well as a <strong>large safe prime</strong> and a <strong>generator</strong>.</li><li>The client generates a <strong>private key</strong> and calculates a <strong>public key</strong>. Then it calculates a <strong>session key</strong> and <strong>client proof</strong>. It then
sends both the <strong>public key</strong> and <strong>client proof</strong> to the server.</li><li>The server calculates a <strong>session key</strong>, then calculates the <strong>client proof</strong> on its own and compares it to the one the client sent.
If they are identical the client and server have used the same password for their calculations.
The server then sends a <strong>server proof</strong> to the client to prove that it also knows the correct password.</li><li>If the client gets an identical <strong>server proof</strong> it is now authenticated and will send the &ldquo;Send Realmlist&rdquo; packet to ask the server to send a realmlist.</li><li>If the client loses connection, it can reconnect by proving that it knows the original session key. More on this in the <a href=#reconnecting>Reconnecting</a> section.</li></ol><p>The above description can also be seen as a sequence diagram in figure 1.</p><figure><img src=srp6-overview.svg alt="A sequence diagram of the SRP6 process as previously described."><figcaption><b>Figure 1:</b> A sequence diagram of the SRP6 process as previously described.<br><a href=srp6-overview.wsd>PlantUML Source</a></figcaption></figure><p>There are some important conceptual points to remember:</p><ol><li>The <strong>private keys</strong> are never sent over the network. Only the client will know what the <strong>client private key</strong> is, and only
the server will know what the <strong>server private key</strong> is. Both values are chosen completely at random and are not identical.</li><li>The <strong>public keys</strong> are sent over the network and are not identical.</li><li>The <strong>session keys</strong> are calculated by both the client and the server based on different variables.
These keys are identical and the <strong>client proof</strong> and <strong>server proof</strong> prove to the other part that they both have the same <strong>session key</strong>
without saying what the key is.</li><li>The <strong>client proof</strong> and <strong>server proof</strong> are calculated using the public information and their respective <strong>session keys</strong>. This means that the
client calculates a <strong>client proof</strong>, then the server calculates a <strong>client proof</strong> using the same algorithm and if the <strong>client proofs</strong> match the <strong>session keys</strong> used are identical.
The same happens for the <strong>server proofs</strong>.</li></ol><p><a href=#reconnecting>Reconnecting</a> and <a href=#world-packet-header-encryption>packet header encryption</a> are described in their own sections.</p><h2 id=important-knowledge-before-starting>Important Knowledge Before Starting</h2><p>Before we dive into the implementation itself, there are a few things you should know that would
ease your implementation.</p><h3 id=integers>Integers</h3><p>You will need to convert an array of bytes to a number, this is often called a <code>BigInt</code>, <code>BigInteger</code> or arbitrary size integer.
You might need a third party library for this although some languages do have standard library support for this.</p><p>The integers should be <strong>signed and positive</strong>.</p><h4 id=convertion-of-hexadecimal-strings-to-byte-arrays>Convertion of hexadecimal strings to byte arrays</h4><p>When using the provided examples you will need to convert a hexadecimal string to arrays of bytes.
It&rsquo;s important to understand the difference between a byte array of a hexadecimal integer, and a byte array of a string.</p><p>Hexadecimal strings can be thought of as containing a byte every 2 characters.
So the string <code>FF</code> would be an array with a single element containing the value <code>255</code> (<code>0xFF</code>), while the string <code>FFEE</code> would be an array with two elements containg the value <code>255</code> (<code>0xFF</code>) and the value <code>238</code> (<code>0xEE</code>).</p><p>A byte array of a string are the literal values that represent the characters in the string, while a byte of array of an integer are the individual components of the integer.
So the byte array of the hexadecimal string <code>FF</code> would contain two elements with the value <code>70</code> (0x46) and the value <code>70</code>, since these are the ASCII/UTF-8 values of the <code>F</code> character.</p><p>Consider two the functions <code>HexToBytes</code> and <code>StringToBytes</code>.
<code>HexToBytes</code> converts a hexadecimal string to an array of the byte values while <code>StringToBytes</code> converts any string to an array of the character values.</p><p>If you read one of the examples and get the hexadecimal string <code>ABCDEF</code> you can test whether you have a byte array of the string or the byte values by checking the length of the returned by array.</p><p>The array returned by <code>HexToBytes</code> for the string <code>ABCDEF</code> would contain 3 elements (<code>[ 0xAB, 0xCD, 0xEF ]</code>), while the array returned by <code>StringToBytes</code> for the string <code>ABCDEF</code> would contain 6 elements (<code>[ 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 ]</code>).</p><h3 id=endianness>Endianness</h3><p>All operations are performed on <strong>little endian</strong> arrays.
This means that if your arbitrary size integer has generic
<code>as_bytes()</code>, <code>to_bytes()</code> or <code>from_bytes()</code> functions, you will need to investigate which endianness it expects and outputs.</p><p>To visualize endianness consider the <a href=https://simple.wikipedia.org/wiki/Hexadecimal>hexadecimal (base/radix 16)</a> number <code>0xABCD</code> (43981 in <a href=https://simple.wikipedia.org/wiki/Decimal_numeral_system>decimal (base/radix 10)</a>).</p><p>Most hexadecimal string parsers would consider the number to be in big endian representation with the most significant digit <code>A</code> to the far left representing the digit that would affect the number most if changed, in the same way that <code>1</code> is the most significant digit in <code>100</code> (one hundred).</p><p>If you convert the number to big endian bytes the most significant byte, <code>AB</code>, is in the first position and the rest follow along.
In little endian bytes the least significant byte, <code>CD</code>, is the in the first position followed by the second least significant byte, <code>AB</code> in this case.</p><p>See the psuedo code below to build a mental model of endianness.</p><pre tabindex=0><code>BigInt value = 0xABCD
byte[] big_endian = { 0xAB, 0xCD }
byte[] little_endian = { 0xCD, 0xAB }
</code></pre><p>To test your <code>BigInt</code> implementation, try to load up the hexadecimal number <code>ABCD</code> and get it as bytes.
The Rust <code>num_bigint</code> library has both <code>to_bytes_le()</code> and <code>to_bytes_be()</code> so there&rsquo;s no confusion.
Make a note of whether the bytes you get are little endian or big endian.</p><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f5f7ea4392b514ca20be74d23ad6f122">Rust Playground</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> num_bigint; <span style=color:#75715e>// 0.4.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>use</span> num_traits::Num;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> number <span style=color:#f92672>=</span> num_bigint::BigInt::from_str_radix(<span style=color:#e6db74>&#34;ABCD&#34;</span>, <span style=color:#ae81ff>16</span>).unwrap();
</span></span><span style=display:flex><span>    dbg!(<span style=color:#f92672>&amp;</span>number.to_bytes_be()); <span style=color:#75715e>// Outputs [ 171, 205 ] which is [ 0xAB, 0xCD ] in hex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    dbg!(<span style=color:#f92672>&amp;</span>number.to_bytes_le()); <span style=color:#75715e>// Outputs [ 205, 171 ] which is [ 0xCD, 0xAB ] in hex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Remember that there&rsquo;s a different between the string representation and the literal bytes representation.
A hexadecimal string is just a human readable representation of the value, the value of the characters that make up the string is not the same.</p><h3 id=padding>Padding</h3><p>All operations are performed on padded arrays, the sizes for different types can be seen below.
Do not worry about understanding why the different sizes are chosen, most are simply the result of the client not being able to accept higher values or having fixed sized fields.</p><table><thead><tr><th>Type</th><th>Size (bytes)</th><th>Reason</th></tr></thead><tbody><tr><td>Session Key</td><td>40</td><td>Two SHA-1 hashes appended are always 40 bytes.</td></tr><tr><td>Server and Client Proof</td><td>20</td><td>Result of SHA-1 hash is always 20 bytes.</td></tr><tr><td>Public Key</td><td>32</td><td>Packet field is always 32 bytes.</td></tr><tr><td>Private Key</td><td>32</td><td>Arbitrarily chosen.</td></tr><tr><td>Salt</td><td>32</td><td>Packet field is always 32 bytes.</td></tr><tr><td>Password Verifier</td><td>32</td><td>Result of modulus large safe prime is always 32 bytes or less.</td></tr><tr><td>Large Safe Prime</td><td>32</td><td>Largest value client will accept. Any larger can result in public key not fitting into packet field.</td></tr><tr><td>S Key</td><td>32</td><td>Result of modulus large safe prime is always 32 bytes or less.</td></tr><tr><td>Reconnect Seed Data</td><td>16</td><td>Packet field is always 16 bytes for both client and server.</td></tr><tr><td>Generator</td><td>1</td><td>There is no reason to have a generator value above 255.</td></tr></tbody></table><h3 id=hashing>Hashing</h3><p>All operations use SHA-1 which produces an output of 20 bytes.</p><p>To test that your SHA-1 implementation works correctly, ensure that hashing the string <code>test</code> leads to the output of <code>a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</code>, and that hashing the bytes <code>0x53 0x51</code> leads to <code>0c3d7a19ac7c627290bf031ec3df76277b0f7f75</code>.</p><h3 id=constants>Constants</h3><p>The <strong>large safe prime</strong> should always be <code>0x894B645E89E1535BBDAD5B8B290650530801B18EBFBF5E8FAB3C82872A3E9BB7</code> (big endian string).
The <strong>large safe prime</strong> can be expressed as a <strong>little endian</strong> Rust array like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> LARGE_SAFE_PRIME_LITTLE_ENDIAN: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>32</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0xb7</span>, <span style=color:#ae81ff>0x9b</span>, <span style=color:#ae81ff>0x3e</span>, <span style=color:#ae81ff>0x2a</span>, <span style=color:#ae81ff>0x87</span>, <span style=color:#ae81ff>0x82</span>, <span style=color:#ae81ff>0x3c</span>, <span style=color:#ae81ff>0xab</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x8f</span>, <span style=color:#ae81ff>0x5e</span>, <span style=color:#ae81ff>0xbf</span>, <span style=color:#ae81ff>0xbf</span>, <span style=color:#ae81ff>0x8e</span>, <span style=color:#ae81ff>0xb1</span>, <span style=color:#ae81ff>0x01</span>, <span style=color:#ae81ff>0x08</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x53</span>, <span style=color:#ae81ff>0x50</span>, <span style=color:#ae81ff>0x06</span>, <span style=color:#ae81ff>0x29</span>, <span style=color:#ae81ff>0x8b</span>, <span style=color:#ae81ff>0x5b</span>, <span style=color:#ae81ff>0xad</span>, <span style=color:#ae81ff>0xbd</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x5b</span>, <span style=color:#ae81ff>0x53</span>, <span style=color:#ae81ff>0xe1</span>, <span style=color:#ae81ff>0x89</span>, <span style=color:#ae81ff>0x5e</span>, <span style=color:#ae81ff>0x64</span>, <span style=color:#ae81ff>0x4b</span>, <span style=color:#ae81ff>0x89</span>
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>or as a <strong>big endian</strong> Rust array like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> LARGE_SAFE_PRIME_BIG_ENDIAN: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>32</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x89</span>, <span style=color:#ae81ff>0x4b</span>, <span style=color:#ae81ff>0x64</span>, <span style=color:#ae81ff>0x5e</span>, <span style=color:#ae81ff>0x89</span>, <span style=color:#ae81ff>0xe1</span>, <span style=color:#ae81ff>0x53</span>, <span style=color:#ae81ff>0x5b</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0xbd</span>, <span style=color:#ae81ff>0xad</span>, <span style=color:#ae81ff>0x5b</span>, <span style=color:#ae81ff>0x8b</span>, <span style=color:#ae81ff>0x29</span>, <span style=color:#ae81ff>0x06</span>, <span style=color:#ae81ff>0x50</span>, <span style=color:#ae81ff>0x53</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x08</span>, <span style=color:#ae81ff>0x01</span>, <span style=color:#ae81ff>0xb1</span>, <span style=color:#ae81ff>0x8e</span>, <span style=color:#ae81ff>0xbf</span>, <span style=color:#ae81ff>0xbf</span>, <span style=color:#ae81ff>0x5e</span>, <span style=color:#ae81ff>0x8f</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0xab</span>, <span style=color:#ae81ff>0x3c</span>, <span style=color:#ae81ff>0x82</span>, <span style=color:#ae81ff>0x87</span>, <span style=color:#ae81ff>0x2a</span>, <span style=color:#ae81ff>0x3e</span>, <span style=color:#ae81ff>0x9b</span>, <span style=color:#ae81ff>0xb7</span>,
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>The <strong>generator</strong> should always be <code>7</code>.</p><p>The <strong>k</strong> value should always be <code>3</code>.</p><h3 id=aliases>Aliases</h3><p>Previously terms like <strong>client public key</strong> and <strong>large safe prime</strong> have been used instead of the single letters <code>A</code> and <code>N</code> which are used in <a href=https://tools.ietf.org/html/rfc2945>RFC2945</a>.</p><p>The one letter abbreviations are in my opinion difficult to remember and internalize unless you already know what they mean beforehand.
The long forms will therefore be used, and the table below will serve as a translation between the long and short forms.
Not all terms have a long term, since some terms only exist as intermediate results.</p><table><thead><tr><th>Short Form</th><th>Long Form</th></tr></thead><tbody><tr><td><code>A</code></td><td>Client public key</td></tr><tr><td><code>a</code></td><td>Client private key</td></tr><tr><td><code>B</code></td><td>Server public key</td></tr><tr><td><code>b</code></td><td>Server private key</td></tr><tr><td><code>N</code></td><td>Large safe prime</td></tr><tr><td><code>g</code></td><td>Generator</td></tr><tr><td><code>k</code></td><td>K value</td></tr><tr><td><code>s</code></td><td>Salt</td></tr><tr><td><code>U</code></td><td>Username</td></tr><tr><td><code>p</code></td><td>Password</td></tr><tr><td><code>v</code></td><td>Password verifier</td></tr><tr><td><code>M1</code></td><td>Client proof (proof first sent by client, calculated by both)</td></tr><tr><td><code>M2</code></td><td>Server proof (proof first sent by server, calculated by both)</td></tr><tr><td><code>M</code></td><td>(Client or server) proof</td></tr><tr><td><code>S</code></td><td>S key</td></tr><tr><td><code>K</code></td><td>Session key</td></tr></tbody></table><h2 id=implementation-details>Implementation Details</h2><p>This section describes how to implement the algorithm on a function-by-function basis.
A completely functional program will only be possible once everything except for the Reconnect proof has been implemented.
Test against the provided text files for every function to ensure that no mistakes occur.</p><p>The <a href=https://github.com/gtker/wow_srp>wow_srp</a> Rust crate implements the full algorithm, with examples for both client and server located in the <a href=https://github.com/gtker/wow_srp/tree/main/examples>examples/</a> directory.
<a href=https://github.com/EmberEmu/Ember/tree/development/src/libs/srp6>Ember</a> has a C++ version.
<a href=https://gitlab.com/shadowburn/shadowburn/-/tree/master/apps/logind>Shadowburn</a> has an Elixir version.
<a href=https://github.com/oiramario/wow_srp6>wow_srp6</a> is a Python version.</p><p>The various Mangos forks and derivatives also have SRP6 implementations but these are of very low quality and some will produce incorrect results in as often as 1/1000 cases.</p><h3 id=password-verifier>Password Verifier</h3><p>The password verifier, <code>v</code>, is calculated as <code>v = g^x % N</code>, where:</p><ul><li><p><code>g</code> is the static <strong>generator</strong> equal to 7 defined in <a href=#constants>Constants</a>.</p></li><li><p><code>x</code> is discussed below.</p></li><li><p><code>%</code> is the modulo operator.</p></li><li><p><code>N</code> is the static <strong>large safe prime</strong> defined in <a href=#constants>Constants</a>.</p></li></ul><p>Calculating the password verifier in pseudo code would look like</p><pre tabindex=0><code>function calculate_password_verifier
    argument username: string
    argument password: string
    argument salt: little endian array of 32 bytes
    returns little endian array of 32 bytes

    x = calculate_x(username, password, salt)

    // modpow is a power of and modulo operation in the same function
    return g.modpow(x, large_safe_prime)
</code></pre><h5 id=implementations>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L105>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/include/srp6/Generator.h#L29>C++ (Ember)</a>. Slightly confusing way of doing it. Callsite is <a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/include/srp6/Util.h#L46>here</a>, then <a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/include/srp6/Util.h#L53>here</a> and then <a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L192>here</a>.</li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/common/lib/accounts/accounts.ex#L88>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L46>Python (wow_srp6)</a></li></ul><h5 id=verification-values>Verification values</h5><ul><li><a href=verification_values/calculate_v_values.txt>calculate_v_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Username</th><th>Password</th><th>Salt</th><th>Expected</th></tr></thead><tbody><tr><td>String</td><td>String</td><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h4 id=calculating-x>Calculating <code>x</code></h4><p>The <code>x</code> value is calculated as <code>x = SHA1( s | SHA1( U | : | p ))</code>, where:</p><ul><li><p><code>U</code> is the uppercased <strong>username</strong> of the user. See <a href=#notes-on-uppercasing-username-and-password>this section</a> for notes.</p></li><li><p><code>p</code> is the uppercased <strong>password</strong> of the user. See <a href=#notes-on-uppercasing-username-and-password>this section</a> for notes.</p></li><li><p><code>s</code> is the randomly generated <strong>salt</strong> value for the user.</p></li><li><p><code>|</code> is concatenating the values.</p></li><li><p><code>SHA1</code> is SHA-1 hashing the values.</p></li><li><p><code>:</code> is the literal character <code>:</code>.</p></li></ul><p>Calculating <code>x</code> in pseudo code would look like</p><pre tabindex=0><code>function calculate_x
    argument username: string
    argument password: string
    argument salt: little endian array of 32 bytes
    returns little endian array of 20 bytes

    interim = SHA1( username + &#34;:&#34; + password )

    // Array concatenation
    return SHA1( salt + interim )
</code></pre><h5 id=implementations-1>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L66>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/03c130d3d6276e7032fc9e13c9d287ea7c6ed536/src/libs/srp6/src/Util.cpp#L97>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/common/lib/accounts/accounts.ex#L82>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L37>Python (wow_srp6)</a></li></ul><h5 id=verification-values-1>Verification values</h5><ul><li><a href=verification_values/calculate_x_salt_values.txt>calculate_x_salt_values.txt</a> assumes a static <strong>username</strong> of <code>USERNAME123</code> and a static <strong>password</strong> of <code>PASSWORD123</code>.
It contains the columns:</li></ul><table><thead><tr><th>Salt</th><th>Expected</th></tr></thead><tbody><tr><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><ul><li><a href=verification_values/calculate_x_values.txt>calculate_x_values.txt</a> assumes a static <strong>salt</strong> of <code>0xCAC94AF32D817BA64B13F18FDEDEF92AD4ED7EF7AB0E19E9F2AE13C828AEAF57</code> (big endian).
It contains the columns:</li></ul><table><thead><tr><th>Username</th><th>Password</th><th>Expected</th></tr></thead><tbody><tr><td>String</td><td>String</td><td>Big Endian Hex</td></tr></tbody></table><h3 id=server-public-key>Server public key</h3><p>The <strong>server public key</strong>, <code>B</code>, is calculated as <code>B = (k * v + (g^b % N)) % N</code>, where:</p><ul><li><p><code>k</code> is a <strong>k value</strong> statically defined in <a href=#constants>Constants</a>.</p></li><li><p><code>v</code> is the <strong>password verifier</strong> for the user.</p></li><li><p><code>g</code> is a <strong>generator</strong> statically defined in <a href=#constants>Constants</a>.</p></li><li><p><code>b</code> is the <strong>server private key</strong>.</p></li><li><p><code>%</code> is the modulo operator.</p></li><li><p><code>N</code> is a <strong>large safe prime</strong> statically defined in <a href=#constants>Constants</a>.</p></li></ul><p>Calculating the <strong>server public key</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_server_public_key
    argument password_verifier: BigInteger type
    argument server_private_key: BigInteger type
    returns little endian array of 32 bytes

    // modpow is a power of and modulo operation in the same function
    interim = k_value * password_verifier 
        + generator.modpow(server_private_key, large_safe_prime)
    return interim % large_safe_prime
</code></pre><h5 id=implementations-2>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L122>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L25>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/character-login/apps/logind/lib/authenticator.ex#L386>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L55>Python (wow_srp6)</a></li></ul><h5 id=verification-values-2>Verification values</h5><ul><li><a href=verification_values/calculate_B_values.txt>calculate_B_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Password Verifier</th><th>Server Private Key</th><th>Expected</th></tr></thead><tbody><tr><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h3 id=session-key>Session key</h3><p>The <strong>session key</strong>, <code>K</code>, is calculated differently depending on whether it is the client or server doing the calculation because they only have access to their own <strong>private keys</strong>.</p><p>Both ways calculate an interim <strong>S key</strong> value that is finally <strong>interleaved</strong> in order to get the common <strong>session key</strong>.</p><p>For completeness, both the server and client <strong>session key</strong>, <code>K</code>, is calculated as <code>K = interleaved(S)</code>, where <code>interleaved</code> is a function described below.
The calculation of the client and server <strong>S keys</strong> are below.</p><h4 id=client-s-key>Client S Key</h4><p>The <strong>client S Key</strong>, <code>S</code>, is calculated as <code>S = (B - (k * (g^x % N)))^(a + u * x) % N</code>, where:</p><ul><li><p><code>g</code> is a <strong>generator</strong> statically defined in <a href=#constants>Constants</a>.</p></li><li><p><code>%</code> is the modulo operator.</p></li><li><p><code>N</code> is a <strong>large safe prime</strong> statically defined in <a href=#constants>Constants</a>.</p></li><li><p><code>k</code> is a <strong>k value</strong> statically defined in <a href=#constants>Constants</a>.</p></li><li><p><code>a</code> is the <strong>client private key</strong>.</p></li><li><p><code>B</code> is the <strong>server public key</strong>.</p></li><li><p><code>x</code> is an interim value described under the <a href=#calculating-x>Password Verifier</a> section.</p></li><li><p><code>u</code> is an interim value described below.</p></li></ul><p>Calculating the <strong>client S key</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_client_S_key
    argument client_private_key: little endian array of 32 bytes
    argument server_public_key: little endian array of 32 bytes
    argument x: little endian array of 32 bytes
    argument u: little endian array of 32 bytes
    returns little endian array of 32 bytes

    S = (server_public_key - (k * g.modpow(x, large_safe_prime))).modpow(client_private_key + u * x, large_safe_prime)
    return S
</code></pre><h5 id=implementations-3>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal_client.rs#L24>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Client.cpp#L59>C++ (Ember)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L66>Python (wow_srp6)</a></li></ul><h5 id=verification-values-3>Verification values</h5><ul><li><a href=verification_values/calculate_client_S_values.txt>calculate_client_S_values.txt</a> expects a static <strong>generator</strong> and <strong>large safe prime</strong> from <a href=#constants>Constants</a>, and contains the columns:</li></ul><table><thead><tr><th>Server Public Key</th><th>Client Private Key</th><th>x</th><th>u</th><th>Expected</th></tr></thead><tbody><tr><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h4 id=server-s-key>Server S Key</h4><p>The <strong>server S key</strong>, <code>S</code>, is calculated as <code>S = (A * (v^u % N))^b % N</code>, where:</p><ul><li><p><code>A</code> is the <strong>client public key</strong>.</p></li><li><p><code>v</code> is the <strong>password verifier</strong> for the user.</p></li><li><p><code>%</code> is the modulo operator.</p></li><li><p><code>N</code> is a <strong>large safe prime</strong> statically defined in <a href=#constants>Constants</a>.</p></li><li><p><code>b</code> is the <strong>server private key</strong>.</p></li><li><p><code>u</code> is an interim value described below.</p></li></ul><p>Calculating the <strong>server S key</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_server_S_key
    argument client_public_key: BigInteger type
    argument password_verifier: BigInteger type
    argument u: BigInteger type
    argument server_private_key: BigInteger type
    returns little endian array of 32 bytes

    S = (client_public_key * password_verifier.modpow(u, large_safe_prime))
                .modpow(server_private_key, large_safe_prime)

    return S
</code></pre><h5 id=implementations-4>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L148>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L45>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L395>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L78>Python (wow_srp6)</a></li></ul><h5 id=verification-values-4>Verification values</h5><ul><li><a href=verification_values/calculate_S_values.txt>calculate_S_values.txt</a> expects a static <strong>generator</strong> and <strong>large safe prime</strong> from <a href=#constants>Constants</a>, and contains the columns:</li></ul><table><thead><tr><th>Client Public Key</th><th>Password Verifier</th><th>u</th><th>Server Private Key</th><th>Expected</th></tr></thead><tbody><tr><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h4 id=u>u</h4><p>The <code>u</code> value is calculated as <code>u = SHA1( A | B )</code>, where:</p><ul><li><p><code>A</code> is the client public key.</p></li><li><p><code>B</code> is the server public key.</p></li><li><p><code>SHA1</code> is SHA-1 hashing.</p></li><li><p><code>|</code> is array concatenation.</p></li></ul><p>Calculating the <strong>server S key</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_u
    argument client_public_key: little endian array of 32 bytes
    argument server_public_key: little endian array of 32 bytes
    returns little endian array of 20 bytes
    
    return SHA1( A + B )
</code></pre><h5 id=implementations-5>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L137>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L44>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L394>Elixir (Shadowburn)</a> where it&rsquo;s called the scrambler.</li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L90>Python (wow_srp6)</a></li></ul><h5 id=verification-values-5>Verification values</h5><ul><li><a href=verification_values/calculate_u_values.txt>calculate_u_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Client Public Key</th><th>Server Public Key</th><th>Expected</th></tr></thead><tbody><tr><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h4 id=interleaved>Interleaved</h4><p>The <strong>interleaved</strong> function converts the <strong>S key</strong> to the <strong>session key</strong>.
It is calculated as <code>K = SHA_Interleave(S)</code>, where:</p><ul><li><p><code>K</code> is the <strong>session key</strong>.</p></li><li><p><code>S</code> is the <strong>S key</strong>.</p></li><li><p><code>SHA_Interleave()</code> is a function described below:</p></li></ul><p>If the least significant byte is 0, the <strong>two</strong> least significant bytes are removed.
If the next least significant byte is also 0, the two new least significant bytes are again removed.
This process continues until the least significant byte is not equal to 0.
The even elements of the split <strong>S key</strong> are then hashed, as are the odd elements.
The two hashes are then zipped together, with the even elements in the first position.</p><p>The <code>SHA_Interleave()</code> function in pseudo code would look like:</p><pre tabindex=0><code>function split_s_key
    argument s_key: little endian array of 32 bytes

    // While the _least_ significant byte is 0,
    // remove the 2 least significant bytes.
    // Always keep the length even without
    // trailing zero elements
    while s_key[0] == 0
        // In the pseudo code the s_key variable is modified in place
        // so the first iteration `s_key` has length 32, in the second
        // it has length 30, and so on.
        s_key = s_key[2:]

    return s_key
        

function SHA_Interleave
    argument s_key: little endian array of 32 bytes

    split_s_key = split_s_key(s_key)

    E = dynamic vector of bytes
    // Only add the even elements
    for i in split_s_key.even_elements
        E.push(i)
    G = SHA1(E)
        
    F = dynamic vector of bytes
    for i in split_s_key.odd_elements
        F.push(i)
    H = SHA1(F) 

    session_key = little endian array of 40 bytes
    for i = 0, while i &lt; 20, i += 2
        session_key[i * 2] = G[i]
        session_key[(i * 2) + 1] = H[i]

    return session_key
</code></pre><h5 id=implementations-6>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/6cfef1615cf412b6580608126922c7050ff3af8d/src/key.rs#L293>Rust (wow_srp) (<code>split_s_key</code>)</a></li><li><a href=https://github.com/gtker/wow_srp/blob/6cfef1615cf412b6580608126922c7050ff3af8d/src/srp_internal.rs#L156>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L42>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L417>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L98>Python (wow_srp6)</a></li></ul><h5 id=verification-values-6>Verification values</h5><ul><li><a href=verification_values/calculate_interleaved_values.txt>calculate_interleaved_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>S Key</th><th>Expected</th></tr></thead><tbody><tr><td>Little Endian Hex</td><td>Little Endian Hex</td></tr></tbody></table><h3 id=server-proof>Server proof</h3><p>The <strong>server proof</strong>, <code>M2</code> or sometimes just <code>M</code>, is calculated as <code>M2 = SHA1(A | M1 | K)</code>, where:</p><ul><li><p><code>A</code> is the <strong>client public key</strong>.</p></li><li><p><code>M1</code> is the <strong>client proof</strong>. Remember that <code>M1</code> <strong>must</strong> be calculated and verified on the server before this calculation takes place.</p></li><li><p><code>K</code> is the <strong>session key</strong>.</p></li><li><p><code>|</code> is concatenation.</p></li></ul><p>Calculating the <strong>server proof</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_server_proof
    argument client_public_key: little endian array of 32 bytes
    argument client_proof: little endian array of 20 bytes
    argument session_key: little endian array of 40 bytes
    returns little endian array of 20 bytes (SHA1 hash)

    // Array concatenation
    return SHA1(client_public_key + client_proof + session_key)
</code></pre><h5 id=implementations-7>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L211>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L57>C++ (Ember)</a> calls into <a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L169>here</a>.</li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L413>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L124>Python (wow_srp6)</a></li></ul><h5 id=verification-values-7>Verification values</h5><ul><li><a href=verification_values/calculate_M2_values.txt>calculate_M2_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Client Public Key</th><th>Client Proof</th><th>Session Key</th><th>Expected</th></tr></thead><tbody><tr><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Little Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h3 id=client-proof>Client proof</h3><p>The <strong>client proof</strong>, <code>M1</code> or sometimes just <code>M</code>, is calculated as <code>M1 = SHA1( X | SHA1(U) | s | A | B | K )</code>, where:</p><ul><li><p><code>X</code> is the <code>XOR Hash</code>, described below. It requires the <strong>large safe prime</strong> and the <strong>generator</strong>. Can be precalculated if both are known.</p></li><li><p><code>SHA1(U)</code> is a SHA-1 hash of the uppercased <strong>username</strong>.</p></li><li><p><code>s</code> is the <strong>salt</strong>.</p></li><li><p><code>A</code> is the <strong>client public key</strong>.</p></li><li><p><code>B</code> is the <strong>server public key</strong>.</p></li><li><p><code>K</code> is the <strong>session key</strong>.</p></li></ul><p>Calculating the <strong>client proof</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_client_proof
    argument xor_hash: little endian array of 20 bytes
    argument username: string
    argument session_key: little endian array of 40 bytes
    argument client_public_key: little endian array of 32 bytes
    argument server_public_key: little endian array of 32 bytes
    argument salt: little endian array of 32 bytes

    hashed_username = SHA1( username )
    
    // | is array concatenation
    return SHA1( xor_hash 
                | hashed_username 
                | salt 
                | client_public_key 
                | server_public_key 
                | session_key )
</code></pre><h5 id=implementations-8>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L241>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L134>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L403>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L147>Python (wow_srp6)</a></li></ul><h5 id=verification-values-8>Verification values</h5><ul><li><a href=verification_values/calculate_M1_values.txt>calculate_M1_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Username</th><th>Session Key</th><th>Client Public Key</th><th>Server Public Key</th><th>Salt</th><th>Expected</th></tr></thead><tbody><tr><td>String</td><td>Little endian hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h4 id=xor-hash>XOR Hash</h4><p>This value can be precalculated on the server and you can avoid the calculation.
See the verification values for the value.</p><p>The <code>xor_hash</code> is calculated as <code>SHA1(N) XOR SHA1(g)</code>, where:</p><ul><li><p><code>SHA1(g)</code> is a SHA-1 hash of the <strong>generator</strong> statically defined in <a href=#constants>Constants</a> on the server and variable on the client.</p></li><li><p><code>SHA1(N)</code> is a SHA-1 hash of the <strong>large safe prime</strong> statically defined in <a href=#constants>Constants</a> on the server and variable on the client.</p></li><li><p><code>XOR</code> uses the XOR operator on every element of the two arrays.</p></li></ul><p>Calculating the XOR Hash in pseudo code would look like:</p><pre tabindex=0><code>function calculate_xor_hash
    argument large_safe_prime: little endian array of 32 bytes
    argument generator: byte value
    returns little endian array of 20 bytes (SHA-1 hash)

    hashed_generator = SHA1( generator )
    hashed_large_safe_prime = SHA1( large_safe_prime )

    result is a 20 byte array
    for index in hashed_generator
        result[index] = hashed_generator[index] ^ hashed_large_safe_prime[index]
    end for

    return result
</code></pre><h5 id=implementations-9>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L225>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L142>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L401>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L132>Python (wow_srp6)</a></li></ul><h5 id=verification-values-9>Verification values</h5><p>I do not have verification values, although the precalculated hash with the <a href=#constants>Constant values</a> in Rust is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> PRECALCULATED_XOR_HASH: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>20</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>221</span>, <span style=color:#ae81ff>123</span>, <span style=color:#ae81ff>176</span>, <span style=color:#ae81ff>58</span>, <span style=color:#ae81ff>56</span>, <span style=color:#ae81ff>172</span>, <span style=color:#ae81ff>115</span>, <span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>152</span>, <span style=color:#ae81ff>124</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>80</span>, <span style=color:#ae81ff>111</span>, <span style=color:#ae81ff>202</span>, <span style=color:#ae81ff>150</span>, <span style=color:#ae81ff>108</span>, <span style=color:#ae81ff>123</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>167</span>,
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><h3 id=client-public-key>Client public key</h3><p>Generating the <strong>client public key</strong> is not necessary if you&rsquo;re only writing the server part.</p><p>The <strong>client public key</strong>, <code>A</code>, is calculated as <code>A = g^a % N</code>, where:</p><ul><li><p><code>g</code> is a <strong>generator</strong>. Clients do not get to choose the <strong>generator</strong>, so they can not assume a static value is used.</p></li><li><p><code>a</code> is the <strong>client private key</strong>.</p></li><li><p><code>%</code> is the modulo operator.</p></li><li><p><code>N</code> is a <strong>large safe prime</strong>. Clients do not get to choose the <strong>large safe prime</strong>, so they can not assume a static value is used.</p></li></ul><p>Calculating the <strong>client public key</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_client_public_key
    argument client_private_key: little endian array of 32 bytes
    argument generator: 1 byte integer
    argument large_safe_prime: little endian array of 32 bytes
    returns little endian array of 32 bytes

    // modpow is a power of and modulo operation in the same function
    return generator.modpow(client_private_key, large_safe_prime)
</code></pre><h5 id=implementations-10>Implementations</h5><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal_client.rs#L9>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Client.cpp#L30>C++ (Ember)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L156>Python (wow_srp6)</a></li></ul><h5 id=verification-values-10>Verification values</h5><ul><li><a href=verification_values/calculate_A_values.txt>calculate_A_values.txt</a> expects a static <strong>generator</strong> and <strong>large safe prime</strong> as defined under <a href=#constants>Constants</a>. It contains the columns:</li></ul><table><thead><tr><th>Client Private Key</th><th>Expected</th></tr></thead><tbody><tr><td>Big Endian Hex</td><td>Big Endian Hex</td></tr></tbody></table><h2 id=reconnecting>Reconnecting</h2><p>If a client loses connection with the logon server after getting a <strong>session key</strong> but before connecting to a realm, the client will attempt bypass the creation of a new <strong>session key</strong> by proving to the client that it knows the old <strong>session key</strong>.</p><p>When reconnecting, the protocol works in 6 steps:</p><ol><li>The client sends their <strong>username</strong> to the server.</li><li>The server checks for an existing session with the <strong>username</strong> and creates randomized <strong>server data</strong> that it sends to the client.</li><li>The client generates randomized <strong>client data</strong> and uses the <strong>server data</strong> along with the <strong>username</strong> and <strong>session key</strong> to create a <strong>reconnect proof</strong>. It then sends the <strong>client data</strong> and <strong>reconnect proof</strong> to the server.</li><li>The server calculates their own <strong>reconnect proof</strong> from the <strong>username</strong>, <strong>server data</strong>, <strong>client data</strong>, and <strong>session key</strong> to see if it matches the client <strong>reconnect proof</strong>.</li><li>The client is now authenticated again and will send the &lsquo;Send Realmlist&rsquo; packet to as the server to send a realmlist.</li></ol><p>The above description can also be seen as a sequence diagram in figure 2.</p><figure><img src=reconnect-overview.svg alt="A sequence diagram of the reconnection process as previously described."><figcaption><b>Figure 2:</b> A sequence diagram of the reconnection process as previously described.<br><a href=reconnect-overview.wsd>PlantUML Source</a></figcaption></figure><p>The only function needed for the above is calculating the <strong>reconnect proof</strong> and generating random 16 byte values.</p><h3 id=reconnect-proof>Reconnect proof</h3><p>The <strong>reconnect proof</strong> is not part of SRP6 and does not have a short term. It is calculated the same for the client and server.
The <strong>reconnect proof</strong> is calculated as <code>SHA1( username | client_data | server_data | session_key )</code>, where:</p><ul><li><p><code>username</code> is the <strong>username</strong> of the user attempting to reconnect.</p></li><li><p><code>client_data</code> is the randomized data sent by the client.</p></li><li><p><code>server_data</code> is the randomized data sent by the server.</p></li><li><p><code>session_key</code> is the <strong>session key</strong> from a previous successful authentication.</p></li><li><p><code>|</code> is array concatenation. Strings are converted to UTF-8 bytes.</p></li></ul><p>Calculating the <strong>client public key</strong> in pseudo code would look like:</p><pre tabindex=0><code>function calculate_reconnect_proof
    argument username: string
    argument client_data: little endian array of 16 bytes
    argument server_data: little endian array of 16 bytes
    argument session_key: little endian array of 40 bytes
    returns little endian array of 20 bytes

    return SHA1(username + client_data + server_data + session_key)
</code></pre><h4 id=implementations-11>Implementations</h4><ul><li><a href=https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L263>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/90b9a7b43df4744f856e81e3efcf1de92bcb4ebf/src/login/Authenticator.cpp#L59>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L435>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L166>Python (wow_srp6)</a></li></ul><h4 id=verification-values-11>Verification values</h4><ul><li><a href=verification_values/calculate_reconnection_values.txt>calculate_reconnection_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Username</th><th>Client Data</th><th>Server Data</th><th>Session Key</th></tr></thead><tbody><tr><td>String</td><td>Little Endian Hex</td><td>Little Endian Hex</td><td>Little Endian Hex</td></tr></tbody></table><h2 id=world-packet-header-encryption>World Packet Header Encryption</h2><p><a href=https://wowdev.wiki/World_Packet>World Packets</a> encrypt their header using the <strong>session key</strong>.
None of the <a href=https://wowdev.wiki/Login_Packet>Login Packets</a> require encryption, but this section is included because it can be tedious to implement and is necessary for getting to the character screen.</p><p>The sending party encrypts the header and the receiving party decrypts the header. Client and server headers have different length, but this does not matter since the algorithm works on any amount of bytes.</p><p>The &ldquo;encryption&rdquo; is not real encryption, since it&rsquo;s very easily breakable and can leak the session key which is used for reconnection.</p><p>To be explicit, if you&rsquo;re writing a server you will only ever <strong>decrypt</strong> headers received from the client and <strong>encrypt</strong> headers sent to the client.</p><p>Figure 3 shows both encryption and decryption visually.
Individual images can be found at <a href=encryption/page-0.png>step 1</a>, <a href=encryption/page-1.png>step 2</a>, <a href=encryption/page-2.png>step 3</a>, <a href=encryption/page-3.png>step 4</a> and <a href=encryption/page-4.png>step 5</a>.</p><figure><img src=encryption/encryption.gif alt="The encryption and decryption of example data. The figure is animated. Notice how decryption is just the same process in reverse."><figcaption><b>Figure 3:</b> The encryption and decryption of example data. The figure is animated. Notice how decryption is just the same process in reverse.<br></figure><h3 id=encryption>Encryption</h3><p>Encryption works by XORing the unencrypted value with a byte of the session key and adding the previous encrypted value. The index into the session key is then incremented. This is done for every element of the array to be encrypted.</p><p>The encryption is calculated as <code>E = (x ^ S) + L</code> where:</p><ul><li><p><code>E</code> is the encrypted value, what is sent over the wire.</p></li><li><p><code>x</code> is the unencrypted value, a byte of the opcode or size.</p></li><li><p><code>S</code> is a byte of the session key, incrementing after every encryption.</p></li><li><p><code>L</code> is the last encrypted value. This is <code>E</code> from the previous iteration.</p></li></ul><p>In pseudo code this would look like:</p><pre tabindex=0><code>function encrypt
    argument data: little endian array of length AL
    returns little endian array of length AL
    
    static int index = 0 // Static variables keep their values between function calls
    static int last_value = 0 // Last value starts at zero
    // The session key exists somewhere else as `session_key`

    return_array = {} // Encrypted values

    for unencrypted in data {
        encrypted = (unencrypted ^ session_key[index]) + last_value

        index = (index + 1) % session_key.length // Use the session key as a circular buffer

        return_array.append(encrypted)
        last_value = encrypted
    }

    return return_array
</code></pre><h4 id=implementations-12>Implementations</h4><ul><li><a href=https://github.com/gtker/wow_srp/blob/bc10da51a44b368b64fe5491dc305287bb431e74/src/header_crypto/mod.rs#L106>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/90b9a7b43df4744f856e81e3efcf1de92bcb4ebf/src/gateway/PacketCrypto.h#L44>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/serverd/lib/session.ex#L56>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L173>Python (wow_srp6)</a></li></ul><h4 id=verification-values-12>Verification values</h4><ul><li><a href=verification_values/encryption/calculate_encrypt_values.txt>calculate_encrypt_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Session Key</th><th>Data (50 bytes)</th><th>Expected (50 bytes)</th></tr></thead><tbody><tr><td>Little Endian Hex</td><td>Little Endian Hex</td><td>Little Endian Hex</td></tr></tbody></table><h3 id=decryption>Decryption</h3><p>Decryption does the opposite of encryption. So first the old encrypted value is subtracted from the encrypted value, before it is XORed with the session key.</p><p>The decryption is calculated as <code>x = (E - L) ^ S</code> where:</p><ul><li><p><code>x</code> is the unencrypted value, a byte of the opcode or size.</p></li><li><p><code>E</code> is the encrypted value, what is sent over the wire.</p></li><li><p><code>L</code> is the last encrypted value. This is <code>E</code> from the previous iteration.</p></li><li><p><code>S</code> is a byte of the session key, incrementing after every encryption.</p></li></ul><p>In pseudo code this would look like:</p><pre tabindex=0><code>function decrypt
    argument data: little endian array of length AL
    returns little endian array of length AL
    
    static int index = 0 // Static variables keep their values between function calls
    static int last_value = 0 // Last value starts at zero
    // The session key exists somewhere else as `session_key`

    return_array = {} // Unencrypted values

    for encrypted in data {
        unencrypted = (encrypted - last_value) ^ session_key[index]

        index = (index + 1) % session_key.length // Use the session key as a circular buffer

        last_value = encrypted
        return_array.append(unencrypted)
    }

    return return_array
</code></pre><h4 id=implementations-13>Implementations</h4><ul><li><a href=https://github.com/gtker/wow_srp/blob/bc10da51a44b368b64fe5491dc305287bb431e74/src/header_crypto/mod.rs#L166>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/90b9a7b43df4744f856e81e3efcf1de92bcb4ebf/src/gateway/PacketCrypto.h#L58>C++ (Ember)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/serverd/lib/session.ex#L73>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L191>Python (wow_srp6)</a></li></ul><h4 id=verification-values-13>Verification values</h4><ul><li><a href=verification_values/encryption/calculate_decrypt_values.txt>calculate_decrypt_values.txt</a> contains the columns:</li></ul><table><thead><tr><th>Session Key</th><th>Data (50 bytes)</th><th>Expected (50 bytes)</th></tr></thead><tbody><tr><td>Little Endian Hex</td><td>Little Endian Hex</td><td>Little Endian Hex</td></tr></tbody></table><h3 id=world-server-proof>World Server Proof</h3><p>After receiving the <a href=https://wowdev.wiki/CMSG_AUTH_SESSION><code>CMSG_AUTH_SESSION</code></a> message the server will have to verify that the client does indeed know the correct session key. This is done by having both the server and client use 32 bit (not byte) values as seeds in a hash with the session key.</p><p>The proof is calculated as <code>SHA1( username | 0 | client_seed | server_seed | session_key )</code>, where:</p><ul><li><p><code>username</code> is the <strong>username</strong> of the user attempting to connect.</p></li><li><p><code>0</code> is the literal value zero, taking up 4 bytes (32 bits, a standard <code>int</code>).</p></li><li><p><code>client_seed</code> is a random 4 byte value sent by the client.</p></li><li><p><code>server_seed</code> is a random 4 byte value generated by the server.</p></li><li><p><code>session_key</code> is the <strong>session key</strong> from the original authentication.</p></li></ul><p>Calculating the world proof in pseudo code would look like:</p><pre tabindex=0><code>function calculate_world_server_proof
    argument username: string
    argument client_seed: unsigned 4 byte value, converted to little endian bytes
    argument server_seed: unsigned 4 byte value, converted to little endian bytes
    argument session_key: little endian array of 40 bytes
    returns little endian array of 20 bytes

    zero = [0, 0, 0, 0] // Assume this is a 4 byte array of zeros

    return SHA1(username + zero + client_seed + server_seed + session_key)
</code></pre><h4 id=implementations-14>Implementations</h4><ul><li><a href=https://github.com/gtker/wow_srp/blob/761b040d9d7f18dcb760424eeaef15994f321116/src/srp_internal.rs#L260>Rust (wow_srp)</a></li><li><a href=https://github.com/EmberEmu/Ember/blob/b0dbeb3dc4230a18c7be38c2cedd712ef6e3cfd4/src/gateway/states/Authentication.cpp#L166>C++ (Ember)</a></li><li><a href=https://github.com/mangoszero/server/blob/e45aa74e0fa3a9677d90fc012b8161e1e9935742/src/game/Server/WorldSocket.cpp#L784>C++ (Mangos)</a></li><li><a href=https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/serverd/lib/session.ex#L127>Elixir (Shadowburn)</a></li><li><a href=https://github.com/oiramario/wow_srp6/blob/3bf8e4660a35dbc6a49eb17adae6ec914ac07588/srp6.py#L209>Python (wow_srp6)</a></li></ul><h4 id=verification-values-14>Verification values</h4><ul><li><a href=verification_values/encryption/calculate_world_server_proof.txt>calculate_world_server_proof.txt</a> contains the columns:</li></ul><table><thead><tr><th>Username</th><th>Session Key</th><th>Server Seed</th><th>Client Seed</th><th>Expected</th></tr></thead><tbody><tr><td>String</td><td>Big Endian Hex</td><td>Little Endian Hex</td><td>Little Endian Hex</td><td>Little Endian Hex</td></tr></tbody></table><h2 id=notes-on-uppercasing-username-and-password>Notes on uppercasing username and password</h2><p>The username and password are UTF-8 strings that are automatically uppercased by the client before being sent over the network.
This might present some issues with getting the correct name from the registration form and the client, more information is present at the <a href=https://docs.rs/wow_srp/0.2.0/wow_srp/normalized_string/index.html#background>wow_srp library documentation</a>.</p><h2 id=external-resources>External Resources</h2><ul><li>The <a href=https://shadowburn-project.org/2018/10/17/logging-in-with-vanilla.html>Shadowburn Project</a> has a guide on authenticating that focuses more on the networking and specific packets.</li><li>The <a href=https://wowdev.wiki/Login_Packet>WoWDev Wiki</a> has an overview of packets.</li><li><a href=https://www.wireshark.org/download.html>Wireshark</a> at version 3.5 or greater has support for parsing 1.12 packets through the <code>WOW</code> and <code>WOWW</code> protocols. You <strong>will</strong> need this if you&rsquo;re trying to debug a networked implementation.</li></ul></main><footer><hr>© GTKer.com 2024 | <a href=mailto:contact@gtker.com>Contact</a></footer></body></html>