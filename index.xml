<feed xmlns="http://www.w3.org/2005/Atom"><title>Home on GTKer.com</title><link href="https://gtker.com/index.xml" rel="self"/><link href="https://gtker.com/"/><updated>2021-07-05T00:00:00+00:00</updated><id>https://gtker.com/</id><author><name>Gtker</name><email>contact@gtker.com</email></author><generator>Hugo -- gohugo.io</generator><entry><title type="html">Implementation Guide for the World of Warcraft flavor of SRP6</title><link href="https://gtker.com/implementation-guide-for-the-world-of-warcraft-flavor-of-srp6/"/><id>https://gtker.com/implementation-guide-for-the-world-of-warcraft-flavor-of-srp6/</id><author><name>Gtker</name></author><published>2021-07-05T00:00:00+00:00</published><updated>2022-01-31T00:00:00+00:00</updated><content type="html"><![CDATA[<p>The authentication protocol for authenticating with a World of Warcraft (WoW) server is widely available but not very well documented.
Most documentation is spread across forums or just directly links to <a href="https://tools.ietf.org/html/rfc2945">RFC2945</a>,
the 8 page, 20 year old, very broad and unspecific RFC that describes SRP6 in relatively academic terms.</p>
<p>The goal of this article is to be an approachable,
complete guide to implementing the protocol specifically for WoW 1.12 without requiring external references.</p>
<p>The article starts out by giving a high level overview of the protocol and the specifics of the WoW implementation before
giving a function-by-function implementation guide, including files for verification and examples of implementation in Rust, C++ and Elixir.</p>
<p>Important terms have been highlighted with <strong>bold</strong>. The exact definitions of these will come later in the article.</p>
<p>This article will only cover the SRP6 protocol, not the network aspects of authenticating with a client.</p>
<p><strong>This is not intended to be a guide for production usage. I have no cryptographic experience and essentially stumbled upon the solutions by accident.
SRP6 is also not very widely used, possibly for a reason.
Use this only for interacting with legacy World of Warcraft game clients.</strong></p>
<h2 id="srp6-overview">SRP6 Overview</h2>
<p>SRP6 is a protocol for proving that a client and server both know the same specific password without having to send it over the network.
It does this via various mathematical tricks, none of which are important to us.</p>
<p>When a new account is added, the server generates a random <strong>salt</strong> value and calculates
a <strong>password verifier</strong> before saving the <strong>username</strong>, <strong>salt</strong> and <strong>password verifier</strong> to the database.</p>
<p>When authenticating, the protocol works in 5 different stages:</p>
<ol>
<li>The client sends their <strong>username</strong> to the server.</li>
<li>The server retrieves the <strong>password verifier</strong> and <strong>salt</strong> from the database, then it randomly generates
a <strong>private key</strong> which it uses to calculate a <strong>public key</strong>. It then sends the <strong>public key</strong> and <strong>salt</strong> to the client,
as well as a <strong>large safe prime</strong> and a <strong>generator</strong>.</li>
<li>The client generates a <strong>private key</strong> and calculates a <strong>public key</strong>. Then it calculates a <strong>session key</strong> and <strong>client proof</strong>. It then
sends both the <strong>public key</strong> and <strong>client proof</strong> to the server.</li>
<li>The server calculates a <strong>session key</strong>, then calculates the <strong>client proof</strong> on its own and compares it to the one the client sent.
If they are identical the client and server have used the same password for their calculations.
The server then sends a <strong>server proof</strong> to the client to prove that it also knows the correct password.</li>
<li>If the client gets an identical <strong>server proof</strong> it is now authenticated and will send the &ldquo;Send Realmlist&rdquo; packet to ask the server to send a realmlist.</li>
<li>If the client loses connection, it can reconnect by proving that it knows the original session key. More on this in the <a href="#reconnecting">Reconnecting</a> section.</li>
</ol>
<p>The above description can also be seen as a sequence diagram in figure 1.</p>
<figure>
    <img src="srp6-overview.svg" alt="A sequence diagram of the SRP6 process as previously described."/>
    <figcaption><b>Figure 1:</b> A sequence diagram of the SRP6 process as previously described.
        <br>
        <a href="srp6-overview.wsd">PlantUML Source</a></figcaption>
</figure>

<p>There are some important conceptual points to remember:</p>
<ol>
<li>The <strong>private keys</strong> are never sent over the network. Only the client will know what the <strong>client private key</strong> is, and only
the server will know what the <strong>server private key</strong> is. Both values are chosen completely at random and are not identical.</li>
<li>The <strong>public keys</strong> are sent over the network and are not identical.</li>
<li>The <strong>session keys</strong> are calculated by both the client and the server based on different variables.
These keys are identical and the <strong>client proof</strong> and <strong>server proof</strong> prove to the other part that they both have the same <strong>session key</strong>
without saying what the key is.</li>
<li>The <strong>client proof</strong> and <strong>server proof</strong> are calculated using the public information and their respective <strong>session keys</strong>. This means that the
client calculates a <strong>client proof</strong>, then the server calculates a <strong>client proof</strong> using the same algorithm and if the <strong>client proofs</strong> match the <strong>session keys</strong> used are identical.
The same happens for the <strong>server proofs</strong>.</li>
</ol>
<p><a href="#reconnecting">Reconnecting</a> and <a href="#world-packet-header-encryption">packet header encryption</a> are described in their own sections.</p>
<h2 id="important-knowledge-before-starting">Important Knowledge Before Starting</h2>
<p>Before we dive into the implementation itself, there are a few things you should know that would
ease your implementation.</p>
<h3 id="integers">Integers</h3>
<p>You will need to convert an array of bytes to a number, this is often called a <code>BigInt</code>, <code>BigInteger</code> or arbitrary size integer.
You might need a third party library for this although some languages do have standard library support for this.</p>
<p>The integers should be <strong>signed and positive</strong>.</p>
<h3 id="endianness">Endianness</h3>
<p>All operations are performed on <strong>little endian</strong> arrays.
This means that if your arbitrary size integer has generic
<code>as_bytes()</code>, <code>to_bytes()</code> or <code>from_bytes()</code> functions, you will need to investigate which endianness it expects and outputs.</p>
<p>To visualize endianness consider the <a href="https://simple.wikipedia.org/wiki/Hexadecimal">hexadecimal (base/radix 16)</a> number <code>0xABCD</code> (43981 in <a href="https://simple.wikipedia.org/wiki/Decimal_numeral_system">decimal (base/radix 10)</a>).</p>
<p>Most hexadecimal string parsers would consider the number to be in big endian representation with the most significant digit <code>A</code> to the far left representing the digit that would affect the number most if changed, in the same way that <code>1</code> is the most significant digit in <code>100</code> (one hundred).</p>
<p>If you convert the number to big endian bytes the most significant byte, <code>AB</code>, is in the first position and the rest follow along.
In little endian bytes the least significant byte, <code>CD</code>, is the in the first position followed by the second least significant byte, <code>AB</code> in this case.</p>
<p>See the psuedo code below to build a mental model of endianness.</p>
<pre><code>BigInt value = 0xABCD
byte[] big_endian = { 0xAB, 0xCD }
byte[] little_endian = {0xCD, 0xAB }
</code></pre><p>To test your <code>BigInt</code> implementation, try to load up the hexadecimal number <code>ABCD</code> and get it as bytes.
The Rust <code>num_bigint</code> library has both <code>to_bytes_le()</code> and <code>to_bytes_be()</code> so there&rsquo;s no confusion.
Make a note of whether the bytes you get are little endian or big endian.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f5f7ea4392b514ca20be74d23ad6f122">Rust Playground</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> num_bigint; <span style="color:#75715e">// 0.4.0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> num_traits::Num;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> number <span style="color:#f92672">=</span> num_bigint::BigInt::from_str_radix(<span style="color:#e6db74">&#34;ABCD&#34;</span>, <span style="color:#ae81ff">16</span>).unwrap();
    dbg<span style="color:#f92672">!</span>(<span style="color:#f92672">&amp;</span>number.to_bytes_be()); <span style="color:#75715e">// Outputs [ 171, 205 ] which is [ 0xAB, 0xCD ] in hex
</span><span style="color:#75715e"></span>    dbg<span style="color:#f92672">!</span>(<span style="color:#f92672">&amp;</span>number.to_bytes_le()); <span style="color:#75715e">// Outputs [ 205, 171 ] which is [ 0xCD, 0xAB ] in hex
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Remember that there&rsquo;s a different between the string representation and the literal bytes representation.
A hexadecimal string is just a human readable representation of the value, the value of the characters that make up the string is not the same.</p>
<h3 id="padding">Padding</h3>
<p>All operations are performed on padded arrays, the sizes for different types can be seen below.
Do not worry about understanding why the different sizes are chosen, most are simply the result of the client not being able to accept higher values or having fixed sized fields.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Size (bytes)</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>Session Key</td>
<td>40</td>
<td>Two SHA-1 hashes appended are always 40 bytes.</td>
</tr>
<tr>
<td>Server and Client Proof</td>
<td>20</td>
<td>Result of SHA-1 hash is always 20 bytes.</td>
</tr>
<tr>
<td>Public Key</td>
<td>32</td>
<td>Packet field is always 32 bytes.</td>
</tr>
<tr>
<td>Private Key</td>
<td>32</td>
<td>Arbitrarily chosen.</td>
</tr>
<tr>
<td>Salt</td>
<td>32</td>
<td>Packet field is always 32 bytes.</td>
</tr>
<tr>
<td>Password Verifier</td>
<td>32</td>
<td>Result of modulus large safe prime is always 32 bytes or less.</td>
</tr>
<tr>
<td>Large Safe Prime</td>
<td>32</td>
<td>Largest value client will accept. Any larger can result in public key not fitting into packet field.</td>
</tr>
<tr>
<td>S Key</td>
<td>32</td>
<td>Result of modulus large safe prime is always 32 bytes or less.</td>
</tr>
<tr>
<td>Reconnect Seed Data</td>
<td>16</td>
<td>Packet field is always 16 bytes for both client and server.</td>
</tr>
<tr>
<td>Generator</td>
<td>1</td>
<td>There is no reason to have a generator value above 255.</td>
</tr>
</tbody>
</table>
<h3 id="hashing">Hashing</h3>
<p>All operations use SHA-1 which produces an output of 20 bytes.</p>
<p>To test that your SHA-1 implementation works correctly, ensure that hashing the string <code>test</code> leads to the output of <code>a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</code>, and that hashing the bytes <code>0x53 0x51</code> leads to <code>0c3d7a19ac7c627290bf031ec3df76277b0f7f75</code>.</p>
<h3 id="constants">Constants</h3>
<p>The <strong>large safe prime</strong> should always be <code>0x894B645E89E1535BBDAD5B8B290650530801B18EBFBF5E8FAB3C82872A3E9BB7</code> (big endian string).
The <strong>large safe prime</strong> can be expressed as a <strong>little endian</strong> Rust array like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> LARGE_SAFE_PRIME_LITTLE_ENDIAN: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">32</span>] <span style="color:#f92672">=</span> [
    <span style="color:#ae81ff">0xb7</span>, <span style="color:#ae81ff">0x9b</span>, <span style="color:#ae81ff">0x3e</span>, <span style="color:#ae81ff">0x2a</span>, <span style="color:#ae81ff">0x87</span>, <span style="color:#ae81ff">0x82</span>, <span style="color:#ae81ff">0x3c</span>, <span style="color:#ae81ff">0xab</span>,
    <span style="color:#ae81ff">0x8f</span>, <span style="color:#ae81ff">0x5e</span>, <span style="color:#ae81ff">0xbf</span>, <span style="color:#ae81ff">0xbf</span>, <span style="color:#ae81ff">0x8e</span>, <span style="color:#ae81ff">0xb1</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x08</span>,
    <span style="color:#ae81ff">0x53</span>, <span style="color:#ae81ff">0x50</span>, <span style="color:#ae81ff">0x06</span>, <span style="color:#ae81ff">0x29</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x5b</span>, <span style="color:#ae81ff">0xad</span>, <span style="color:#ae81ff">0xbd</span>,
    <span style="color:#ae81ff">0x5b</span>, <span style="color:#ae81ff">0x53</span>, <span style="color:#ae81ff">0xe1</span>, <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0x5e</span>, <span style="color:#ae81ff">0x64</span>, <span style="color:#ae81ff">0x4b</span>, <span style="color:#ae81ff">0x89</span>
];
</code></pre></div><p>or as a <strong>big endian</strong> Rust array like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> LARGE_SAFE_PRIME_BIG_ENDIAN: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">32</span>] <span style="color:#f92672">=</span> [
    <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0x4b</span>, <span style="color:#ae81ff">0x64</span>, <span style="color:#ae81ff">0x5e</span>, <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0xe1</span>, <span style="color:#ae81ff">0x53</span>, <span style="color:#ae81ff">0x5b</span>,
    <span style="color:#ae81ff">0xbd</span>, <span style="color:#ae81ff">0xad</span>, <span style="color:#ae81ff">0x5b</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x29</span>, <span style="color:#ae81ff">0x06</span>, <span style="color:#ae81ff">0x50</span>, <span style="color:#ae81ff">0x53</span>,
    <span style="color:#ae81ff">0x08</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0xb1</span>, <span style="color:#ae81ff">0x8e</span>, <span style="color:#ae81ff">0xbf</span>, <span style="color:#ae81ff">0xbf</span>, <span style="color:#ae81ff">0x5e</span>, <span style="color:#ae81ff">0x8f</span>,
    <span style="color:#ae81ff">0xab</span>, <span style="color:#ae81ff">0x3c</span>, <span style="color:#ae81ff">0x82</span>, <span style="color:#ae81ff">0x87</span>, <span style="color:#ae81ff">0x2a</span>, <span style="color:#ae81ff">0x3e</span>, <span style="color:#ae81ff">0x9b</span>, <span style="color:#ae81ff">0xb7</span>,
];
</code></pre></div><p>The <strong>generator</strong> should always be <code>7</code>.</p>
<p>The <strong>k</strong> value should always be <code>3</code>.</p>
<h3 id="aliases">Aliases</h3>
<p>Previously terms like <strong>client public key</strong> and <strong>large safe prime</strong> have been used instead of the single letters <code>A</code> and <code>N</code> which are used in <a href="https://tools.ietf.org/html/rfc2945">RFC2945</a>.</p>
<p>The one letter abbreviations are in my opinion difficult to remember and internalize unless you already know what they mean beforehand.
The long forms will therefore be used, and the table below will serve as a translation between the long and short forms.
Not all terms have a long term, since some terms only exist as intermediate results.</p>
<table>
<thead>
<tr>
<th>Short Form</th>
<th>Long Form</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A</code></td>
<td>Client public key</td>
</tr>
<tr>
<td><code>a</code></td>
<td>Client private key</td>
</tr>
<tr>
<td><code>B</code></td>
<td>Server public key</td>
</tr>
<tr>
<td><code>b</code></td>
<td>Server private key</td>
</tr>
<tr>
<td><code>N</code></td>
<td>Large safe prime</td>
</tr>
<tr>
<td><code>g</code></td>
<td>Generator</td>
</tr>
<tr>
<td><code>k</code></td>
<td>K value</td>
</tr>
<tr>
<td><code>s</code></td>
<td>Salt</td>
</tr>
<tr>
<td><code>U</code></td>
<td>Username</td>
</tr>
<tr>
<td><code>p</code></td>
<td>Password</td>
</tr>
<tr>
<td><code>v</code></td>
<td>Password verifier</td>
</tr>
<tr>
<td><code>M1</code></td>
<td>Client proof (proof first sent by client, calculated by both)</td>
</tr>
<tr>
<td><code>M2</code></td>
<td>Server proof (proof first sent by server, calculated by both)</td>
</tr>
<tr>
<td><code>M</code></td>
<td>(Client or server) proof</td>
</tr>
<tr>
<td><code>S</code></td>
<td>S key</td>
</tr>
<tr>
<td><code>K</code></td>
<td>Session key</td>
</tr>
</tbody>
</table>
<h2 id="implementation-details">Implementation Details</h2>
<p>This section describes how to implement the algorithm on a function-by-function basis.
A completely functional program will only be possible once everything except for the Reconnect proof has been implemented.
Test against the provided text files for every function to ensure that no mistakes occur.</p>
<p>The <a href="https://github.com/gtker/wow_srp">wow_srp</a> Rust crate implements the full algorithm, with examples for both client and server located in the <a href="https://github.com/gtker/wow_srp/tree/main/examples">examples/</a> directory.
<a href="https://github.com/EmberEmu/Ember/tree/development/src/libs/srp6">Ember</a> has a C++ version.
<a href="https://gitlab.com/shadowburn/shadowburn/-/tree/master/apps/logind">Shadowburn</a> has an Elixir version.</p>
<h3 id="password-verifier">Password Verifier</h3>
<p>The password verifier, <code>v</code>, is calculated as <code>v = g^x % N</code>, where:</p>
<ul>
<li>
<p><code>g</code> is the static <strong>generator</strong> equal to 7 defined in <a href="#constants">Constants</a>.</p>
</li>
<li>
<p><code>x</code> is discussed below.</p>
</li>
<li>
<p><code>%</code> is the modulo operator.</p>
</li>
<li>
<p><code>N</code> is the static <strong>large safe prime</strong> defined in <a href="#constants">Constants</a>.</p>
</li>
</ul>
<p>Calculating the password verifier in pseudo code would look like</p>
<pre><code>function calculate_password_verifier
    argument username: string
    argument password: string
    argument salt: little endian array of 32 bytes
    returns little endian array of 32 bytes

    x = calculate_x(username, password, salt)

    // modpow is a power of and modulo operation in the same function
    return g.modpow(x, large_safe_prime)
</code></pre><h5 id="implementations">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L105">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/include/srp6/Generator.h#L29">C++ (Ember)</a>. Slightly confusing way of doing it. Callsite is <a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/include/srp6/Util.h#L46">here</a>, then <a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/include/srp6/Util.h#L53">here</a> and then <a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L192">here</a>.</li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/common/lib/accounts/accounts.ex#L88">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_x_values.txt">calculate_x_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Username</th>
<th>Password</th>
<th>Salt</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>String</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h4 id="calculating-x">Calculating <code>x</code></h4>
<p>The <code>x</code> value is calculated as <code>x = SHA1( s | SHA1( U | : | p ))</code>, where:</p>
<ul>
<li>
<p><code>U</code> is the uppercased <strong>username</strong> of the user. See <a href="#notes-on-uppercasing-username-and-password">this section</a> for notes.</p>
</li>
<li>
<p><code>p</code> is the uppercased <strong>password</strong> of the user. See <a href="#notes-on-uppercasing-username-and-password">this section</a> for notes.</p>
</li>
<li>
<p><code>s</code> is the randomly generated <strong>salt</strong> value for the user.</p>
</li>
<li>
<p><code>|</code> is concatenating the values.</p>
</li>
<li>
<p><code>SHA1</code> is SHA-1 hashing the values.</p>
</li>
<li>
<p><code>:</code> is the literal character <code>:</code>.</p>
</li>
</ul>
<p>Calculating <code>x</code> in pseudo code would look like</p>
<pre><code>function caculate_x
    argument username: string
    argument password: string
    argument salt: little endian array of 32 bytes
    returns little endian array of 20 bytes

    interim = SHA1( username + &quot;:&quot; + password )

    // Array concatenation
    return SHA1( salt + interim )
</code></pre><h5 id="implementations-1">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L66">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/03c130d3d6276e7032fc9e13c9d287ea7c6ed536/src/libs/srp6/src/Util.cpp#L97">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/common/lib/accounts/accounts.ex#L82">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values-1">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_x_salt_values.txt">calculate_x_salt_values.txt</a> assumes a static <strong>username</strong> of <code>USERNAME123</code> and a static <strong>password</strong> of <code>PASSWORD123</code>.
It contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Salt</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="verification_values/calculate_x_values.txt">calculate_x_values.txt</a> assumes a static <strong>salt</strong> of <code>0xCAC94AF32D817BA64B13F18FDEDEF92AD4ED7EF7AB0E19E9F2AE13C828AEAF57</code> (big endian).
It contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Username</th>
<th>Password</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>String</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h3 id="server-public-key">Server public key</h3>
<p>The <strong>server public key</strong>, <code>B</code>, is calculated as <code>B = (k * v + (g^b % N)) % N</code>, where:</p>
<ul>
<li>
<p><code>k</code> is a <strong>k value</strong> statically defined in <a href="#constants">Constants</a>.</p>
</li>
<li>
<p><code>v</code> is the <strong>password verifier</strong> for the user.</p>
</li>
<li>
<p><code>g</code> is a <strong>generator</strong> statically defined in <a href="#constants">Constants</a>.</p>
</li>
<li>
<p><code>b</code> is the <strong>server private key</strong>.</p>
</li>
<li>
<p><code>%</code> is the modulo operator.</p>
</li>
<li>
<p><code>N</code> is a <strong>large safe prime</strong> statically defined in <a href="#constants">Constants</a>.</p>
</li>
</ul>
<p>Calculating the <strong>server public key</strong> in pseudo code would look like:</p>
<pre><code>function calculate_server_public_key
    argument password_verifier: little endian array of 32 bytes
    argument server_private_key: little endian array of 32 bytes
    returns little endian array of 32 bytes

    // modpow is a power of and modulo operation in the same function
    interim = k_value * password_verifier 
        + generator.modpow(server_private_key, large_safe_prime)
    return interim % large_safe_prime
</code></pre><h5 id="implementations-2">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L122">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L25">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/character-login/apps/logind/lib/authenticator.ex#L386">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values-2">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_B_values.txt">calculate_B_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Password Verifier</th>
<th>Server Private Key</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h3 id="session-key">Session key</h3>
<p>The <strong>session key</strong>, <code>K</code>, is calculated differently depending on whether it is the client or server doing the calculation because they only have access to their own <strong>private keys</strong>.</p>
<p>Both ways calculate an interim <strong>S key</strong> value that is finally <strong>interleaved</strong> in order to get the common <strong>session key</strong>.</p>
<p>For completeness, both the server and client <strong>session key</strong>, <code>K</code>, is calculated as <code>K = interleaved(S)</code>, where <code>interleaved</code> is a function described below.
The calculation of the client and server <strong>S keys</strong> are below.</p>
<h4 id="client-s-key">Client S Key</h4>
<p>The <strong>client S Key</strong>, <code>S</code>, is calculated as <code>S = (B - (k * (g^x % N)))^(a + u * x) % N</code>, where:</p>
<ul>
<li>
<p><code>g</code> is a <strong>generator</strong> statically defined in <a href="#constants">Constants</a>.</p>
</li>
<li>
<p><code>%</code> is the modulo operator.</p>
</li>
<li>
<p><code>N</code> is a <strong>large safe prime</strong> statically defined in <a href="#constants">Constants</a>.</p>
</li>
<li>
<p><code>k</code> is a <strong>k value</strong> statically defined in <a href="#constants">Constants</a>.</p>
</li>
<li>
<p><code>a</code> is the <strong>client private key</strong>.</p>
</li>
<li>
<p><code>B</code> is the <strong>server public key</strong>.</p>
</li>
<li>
<p><code>x</code> is an interim value described under the <a href="#calculating-x">Password Verifier</a> section.</p>
</li>
<li>
<p><code>u</code> is an interim value described below.</p>
</li>
</ul>
<p>Calculating the <strong>client S key</strong> in pseudo code would look like:</p>
<pre><code>function calculate_client_S_key
    argument client_private_key: little endian array of 32 bytes
    argument server_public_key: little endian array of 32 bytes
    argument x: little endian array of 32 bytes
    argument u: little endian array of 32 bytes
    returns little endian array of 32 bytes

    S = ((B - k) * g.modpow(x, large_safe_prime).modpow(client_private_key + u * x, large_safe_prime)
    return S
</code></pre><h5 id="implementations-3">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal_client.rs#L24">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Client.cpp#L59">C++ (Ember)</a></li>
</ul>
<h5 id="verification-values-3">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_client_S_values.txt">calculate_client_S_values.txt</a> expects a static <strong>generator</strong> and <strong>large safe prime</strong> from <a href="#constants">Constants</a>, and contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Server Public Key</th>
<th>Client Private Key</th>
<th>x</th>
<th>u</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h4 id="server-s-key">Server S Key</h4>
<p>The <strong>server S key</strong>, <code>S</code>, is calculated as <code>S = (A * (v^u % N))^b % N</code>, where:</p>
<ul>
<li>
<p><code>A</code> is the <strong>client public key</strong>.</p>
</li>
<li>
<p><code>v</code> is the <strong>password verifier</strong> for the user.</p>
</li>
<li>
<p><code>%</code> is the modulo operator.</p>
</li>
<li>
<p><code>N</code> is a <strong>large safe prime</strong> statically defined in <a href="#constants">Constants</a>.</p>
</li>
<li>
<p><code>b</code> is the <strong>server private key</strong>.</p>
</li>
<li>
<p><code>u</code> is an interim value described below.</p>
</li>
</ul>
<p>Calculating the <strong>server S key</strong> in pseudo code would look like:</p>
<pre><code>function calculate_server_S_key
    argument client_public_key: little endian array of 32 bytes
    argument password_verifier: little endian array of 32 bytes
    argument u: little endian array of 32 bytes
    argument server_private_key: little endian array of 32 bytes
    returns little endian array of 32 bytes

    S = (client_public_key * password_verifier.modpow(u, large_safe_prime))
                .modpow(server_private_key, large_safe_prime)

    return S
</code></pre><h5 id="implementations-4">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L148">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L45">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L395">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values-4">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_S_values.txt">calculate_S_values.txt</a> expects a static <strong>generator</strong> and <strong>large safe prime</strong> from <a href="#constants">Constants</a>, and contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Client Public Key</th>
<th>Password Verifier</th>
<th>u</th>
<th>Server Private Key</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h4 id="u">u</h4>
<p>The <code>u</code> value is calculated as <code>u = SHA1( A | B )</code>, where:</p>
<ul>
<li>
<p><code>A</code> is the client public key.</p>
</li>
<li>
<p><code>B</code> is the server public key.</p>
</li>
<li>
<p><code>SHA1</code> is SHA-1 hashing.</p>
</li>
<li>
<p><code>|</code> is array concatenation.</p>
</li>
</ul>
<p>Calculating the <strong>server S key</strong> in pseudo code would look like:</p>
<pre><code>function calculate_u
    argument client_public_key: little endian array of 32 bytes
    argument server_public_key: little endian array of 32 bytes
    returns little endian array of 20 bytes
    
    return SHA1( A + B )
</code></pre><h5 id="implementations-5">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L137">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L44">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L394">Elixir (Shadowburn)</a> where it&rsquo;s called the scrambler.</li>
</ul>
<h5 id="verification-values-5">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_u_values.txt">calculate_u_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Client Public Key</th>
<th>Server Public Key</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h4 id="interleaved">Interleaved</h4>
<p>The <strong>interleaved</strong> function converts the <strong>S key</strong> to the <strong>session key</strong>.
It is calculated as <code>K = SHA_Interleave(S)</code>, where:</p>
<ul>
<li>
<p><code>K</code> is the <strong>session key</strong>.</p>
</li>
<li>
<p><code>S</code> is the <strong>S key</strong>.</p>
</li>
<li>
<p><code>SHA_Interleave()</code> is a function described below:</p>
</li>
</ul>
<p>The function removes the 2 <strong>least</strong> significant bytes if least significant byte is 0.
The even elements of the split <strong>S key</strong> are then hashed, as are the odd elements.
The two hashes are then zipped together, with the even elements in the first position.</p>
<p>The <code>SHA_Interleave()</code> function in pseudo code would look like:</p>
<pre><code>function split_s_key
    argument s_key: little endian array of 32 bytes

    // if the _least_ significant byte is 0,
    // remove the 2 least significant bytes
    // Always keep the length even without
    // trailing zero elements
    if s_key[0] == 0
        // 
        return s_key[2..]
        

function calculate_interleaved
    argument s_key: little endian array of 32 bytes

    split_s_key = split_s_key

    E = dynamic vector of bytes
    // Only add the even elements
    for i in split_s_key.even_elements
        E.push(i)
    G = SHA1(E)
        
    F = dynamic vector of bytes
    for i in split_s_key.odd_elements
        F.push(i)
    H = SHA1(F) 

    session_key = little endian array of 40 bytes
    for i = 0, while i &lt; 20, i += 2
        session_key[i * 2] = G[i]
        session_key[(i * 2) + 1] = H[i]

    return session_key
</code></pre><h5 id="implementations-6">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L166">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L42">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L417">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values-6">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_interleaved_values.txt">calculate_interleaved_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>S Key</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
</tr>
</tbody>
</table>
<h3 id="server-proof">Server proof</h3>
<p>The <strong>server proof</strong>, <code>M2</code> or sometimes just <code>M</code>, is calculated as <code>M2 = SHA1(A | M1 | K)</code>, where:</p>
<ul>
<li>
<p><code>A</code> is the <strong>client public key</strong>.</p>
</li>
<li>
<p><code>M1</code> is the <strong>client proof</strong>. Remember that <code>M1</code> <strong>must</strong> be calculated and verified on the server before this calculation takes place.</p>
</li>
<li>
<p><code>K</code> is the <strong>session key</strong>.</p>
</li>
<li>
<p><code>|</code> is concatenation.</p>
</li>
</ul>
<p>Calculating the <strong>server proof</strong> in pseudo code would look like:</p>
<pre><code>function calculate_server_proof
    argument client_public_key: little endian array of 32 bytes
    argument client_proof: little endian array of 20 bytes
    argument session_key: little endian array of 40 bytes
    returns little endian array of 20 bytes (SHA1 hash)

    // Array concatenation
    return SHA1(client_public_key + client_proof + session_key)
</code></pre><h5 id="implementations-7">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L211">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Server.cpp#L57">C++ (Ember)</a> calls into <a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L169">here</a>.</li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L413">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values-7">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_M2_values.txt">calculate_M2_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Client Public Key</th>
<th>Client Proof</th>
<th>Session Key</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Little Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h3 id="client-proof">Client proof</h3>
<p>The <strong>client proof</strong>, <code>M1</code> or sometimes just <code>M</code>, is calculated as <code>M1 = SHA1( X | SHA1(U) | s | A | B | K )</code>, where:</p>
<ul>
<li>
<p><code>X</code> is the <code>XOR Hash</code>, described below. It requires the <strong>large safe prime</strong> and the <strong>generator</strong>. Can be precalculated if both are known.</p>
</li>
<li>
<p><code>SHA1(U)</code> is a SHA-1 hash of the <strong>username</strong>.</p>
</li>
<li>
<p><code>s</code> is the <strong>salt</strong>.</p>
</li>
<li>
<p><code>A</code> is the <strong>client public key</strong>.</p>
</li>
<li>
<p><code>B</code> is the <strong>server public key</strong>.</p>
</li>
<li>
<p><code>K</code> is the <strong>session key</strong>.</p>
</li>
</ul>
<p>Calculating the <strong>client proof</strong> in pseudo code would look like:</p>
<pre><code>function calculate_client_proof
    argument xor_hash: little endian array of 20 bytes
    argument username: string
    argument session_key: little endian array of 40 bytes
    argument client_public_key: little endian array of 32 bytes
    argument server_public_key: little endian array of 32 bytes
    argument salt: little endian array of 32 bytes

    hashed_username = SHA1( username )
    
    // | is array concatenation
    return SHA1( xor_hash 
                | hashed_username 
                | session_key 
                | client_public_key 
                | server_public_key 
                | salt )
</code></pre><h5 id="implementations-8">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L241">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L134">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L403">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values-8">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_M1_values.txt">calculate_M1_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Username</th>
<th>Session Key</th>
<th>Client Public Key</th>
<th>Server Public Key</th>
<th>Salt</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>Little endian hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h4 id="xor-hash">XOR Hash</h4>
<p>This value can be precalculated on the server and you can avoid the calculation.
See the verification values for the value.</p>
<p>The <code>xor_hash</code> is calculated as <code>SHA1(N) XOR SHA1(g)</code>, where:</p>
<ul>
<li>
<p><code>SHA1(g)</code> is a SHA-1 hash of the <strong>generator</strong> statically defined in <a href="#constants">Constants</a> on the server and variable on the client.</p>
</li>
<li>
<p><code>SHA1(N)</code> is a SHA-1 hash of the <strong>large safe prime</strong> statically defined in <a href="#constants">Constants</a> on the server and variable on the client.</p>
</li>
<li>
<p><code>XOR</code> uses the XOR operator on every element of the two arrays.</p>
</li>
</ul>
<p>Calculating the XOR Hash in pseudo code would look like:</p>
<pre><code>function calculate_xor_hash
    argument large_safe_prime: little endian array of 32 bytes
    argument generator: byte value
    returns little endian array of 20 bytes (SHA-1 hash)

    hashed_generator = SHA1( generator )
    hashed_large_safe_prime = SHA1( large_safe_prime )

    result is a 20 byte array
    for index in hashed_generator
        result[index] = hashed_generator[index] ^ hashed_large_safe_prime[index]
    end for

    return result
</code></pre><h5 id="implementations-9">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L225">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Util.cpp#L142">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L401">Elixir (Shadowburn)</a></li>
</ul>
<h5 id="verification-values-9">Verification values</h5>
<p>I do not have verification values, although the precalculated hash with the <a href="#constants">Constant values</a> in Rust is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">const</span> PRECALCULATED_XOR_HASH: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">20</span>] <span style="color:#f92672">=</span> [
    <span style="color:#ae81ff">221</span>, <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">176</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">56</span>, <span style="color:#ae81ff">172</span>, <span style="color:#ae81ff">115</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">152</span>, <span style="color:#ae81ff">124</span>,
    <span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">80</span>, <span style="color:#ae81ff">111</span>, <span style="color:#ae81ff">202</span>, <span style="color:#ae81ff">150</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">194</span>, <span style="color:#ae81ff">167</span>,
];
</code></pre></div><h3 id="client-public-key">Client public key</h3>
<p>Generating the <strong>client public key</strong> is not necessary if you&rsquo;re only writing the server part.</p>
<p>The <strong>client public key</strong>, <code>A</code>, is calculated as <code>A = g^a % N</code>, where:</p>
<ul>
<li>
<p><code>g</code> is a <strong>generator</strong>. Clients do not get to choose the <strong>generator</strong>, so they can not assume a static value is used.</p>
</li>
<li>
<p><code>a</code> is the <strong>client private key</strong>.</p>
</li>
<li>
<p><code>%</code> is the modulo operator.</p>
</li>
<li>
<p><code>N</code> is a <strong>large safe prime</strong>. Clients do not get to choose the <strong>large safe prime</strong>, so they can not assume a static value is used.</p>
</li>
</ul>
<p>Calculating the <strong>client public key</strong> in pseudo code would look like:</p>
<pre><code>function calculate_client_public_key
    argument client_private_key: little endian array of 32 bytes
    argument generator: 1 byte integer
    argument large_safe_prime: little endian array of 32 bytes
    returns little endian array of 32 bytes

    // modpow is a power of and modulo operation in the same function
    return generator.modpow(client_private_key, large_safe_prime)
</code></pre><h5 id="implementations-10">Implementations</h5>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal_client.rs#L9">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/368c9525fb0e550909fabe6ce6e39f029f8634df/src/libs/srp6/src/Client.cpp#L30">C++ (Ember)</a></li>
</ul>
<h5 id="verification-values-10">Verification values</h5>
<ul>
<li><a href="verification_values/calculate_A_values.txt">calculate_A_values.txt</a> expects a static <strong>generator</strong> and <strong>large safe prime</strong> as defined under <a href="#constants">Constants</a>. It contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Client Private Key</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Endian Hex</td>
<td>Big Endian Hex</td>
</tr>
</tbody>
</table>
<h2 id="reconnecting">Reconnecting</h2>
<p>If a client loses connection with the logon server after getting a <strong>session key</strong> but before connecting to a realm, the client will attempt bypass the creation of a new <strong>session key</strong> by proving to the client that it knows the old <strong>session key</strong>.</p>
<p>When reconnecting, the protocol works in 6 steps:</p>
<ol>
<li>The client sends their <strong>username</strong> to the server.</li>
<li>The server checks for an existing session with the <strong>username</strong> and creates randomized <strong>server data</strong> that it sends to the client.</li>
<li>The client generates randomized <strong>client data</strong> and uses the <strong>server data</strong> along with the <strong>username</strong> and <strong>session key</strong> to create a <strong>reconnect proof</strong>. It then sends the <strong>client data</strong> and <strong>reconnect proof</strong> to the server.</li>
<li>The server calculates their own <strong>reconnect proof</strong> from the <strong>username</strong>, <strong>server data</strong>, <strong>client data</strong>, and <strong>session key</strong> to see if it matches the client <strong>reconnect proof</strong>.</li>
<li>The client is now authenticated again and will send the &lsquo;Send Realmlist&rsquo; packet to as the server to send a realmlist.</li>
</ol>
<p>The above description can also be seen as a sequence diagram in figure 2.</p>
<figure>
    <img src="reconnect-overview.svg" alt="A sequence diagram of the reconnection process as previously described."/>
    <figcaption><b>Figure 2:</b> A sequence diagram of the reconnection process as previously described.
        <br>
        <a href="reconnect-overview.wsd">PlantUML Source</a></figcaption>
</figure>

<p>The only function needed for the above is calculating the <strong>reconnect proof</strong> and generating random 16 byte values.</p>
<h3 id="reconnect-proof">Reconnect proof</h3>
<p>The <strong>reconnect proof</strong> is not part of SRP6 and does not have a short term. It is calculated the same for the client and server.
The <strong>reconnect proof</strong> is calculated as <code>SHA1( username | client_data | server_data | session_key )</code>, where:</p>
<ul>
<li>
<p><code>username</code> is the <strong>username</strong> of the user attempting to reconnect.</p>
</li>
<li>
<p><code>client_data</code> is the randomized data sent by the client.</p>
</li>
<li>
<p><code>server_data</code> is the randomized data sent by the server.</p>
</li>
<li>
<p><code>session_key</code> is the <strong>session key</strong> from a previous successful authentication.</p>
</li>
<li>
<p><code>|</code> is array concatenation. Strings are converted to UTF-8 bytes.</p>
</li>
</ul>
<p>Calculating the <strong>client public key</strong> in pseudo code would look like:</p>
<pre><code>function calculate_reconnect_proof
    argument username: string
    argument client_data: little endian array of 16 bytes
    argument server_data: little endian array of 16 bytes
    argument session_key: little endian array of 40 bytes
    returns little endian array of 20 bytes

    return SHA1(username + client_data + server_data + session_key)
</code></pre><h4 id="implementations-11">Implementations</h4>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/b72d2a396d0c9db5df3a6815e8ebf23230c157fe/src/srp_internal.rs#L263">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/90b9a7b43df4744f856e81e3efcf1de92bcb4ebf/src/login/Authenticator.cpp#L59">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/logind/lib/authenticator.ex#L435">Elixir (Shadowburn)</a></li>
</ul>
<h4 id="verification-values-11">Verification values</h4>
<ul>
<li><a href="verification_values/calculate_reconnection_values.txt">calculate_reconnection_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Username</th>
<th>Client Data</th>
<th>Server Data</th>
<th>Session Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
</tr>
</tbody>
</table>
<h2 id="world-packet-header-encryption">World Packet Header Encryption</h2>
<p><a href="https://wowdev.wiki/World_Packet">World Packets</a> encrypt their header using the <strong>session key</strong>.
None of the <a href="https://wowdev.wiki/Login_Packet">Login Packets</a> require encryption, but this section is included because it can be tedious to implement and is necessary for getting to the character screen.</p>
<p>The sending party encrypts the header and the receiving party decrypts the header. Client and server headers have different length, but this does not matter since the algorithm works on any amount of bytes.</p>
<p>The &ldquo;encryption&rdquo; is not real encryption, since it&rsquo;s very easily breakable and can leak the session key which is used for reconnection.</p>
<p>To be explicit, if you&rsquo;re writing a server you will only ever <strong>decrypt</strong> headers received from the client and <strong>encrypt</strong> headers sent to the client.</p>
<p>Figure 3 shows both encryption and decryption visually.
Individual images can be found at <a href="encryption/page-0.png">step 1</a>, <a href="encryption/page-1.png">step 2</a>, <a href="encryption/page-2.png">step 3</a>, <a href="encryption/page-3.png">step 4</a> and <a href="encryption/page-4.png">step 5</a>.</p>
<figure>
    <img src="encryption/encryption.gif" alt="The encryption and decryption of example data. The figure is animated. Notice how decryption is just the same process in reverse."/>
    <figcaption><b>Figure 3:</b> The encryption and decryption of example data. The figure is animated. Notice how decryption is just the same process in reverse.
        <br>
        
</figure>

<h3 id="encryption">Encryption</h3>
<p>Encryption works by XORing the unencrypted value with a byte of the session key and adding the previous encrypted value. The index into the session key is then incremented. This is done for every element of the array to be encrypted.</p>
<p>The encryption is calculated as <code>E = (x ^ S) + L</code> where:</p>
<ul>
<li>
<p><code>E</code> is the encrypted value, what is sent over the wire.</p>
</li>
<li>
<p><code>x</code> is the unencrypted value, a byte of the opcode or size.</p>
</li>
<li>
<p><code>S</code> is a byte of the session key, incrementing after every encryption.</p>
</li>
<li>
<p><code>L</code> is the last encrypted value. This is <code>E</code> from the previous iteration.</p>
</li>
</ul>
<p>In pseudo code this would look like:</p>
<pre><code>function encrypt
    argument data: little endian array of length AL
    returns little endian array of length AL
    
    static int index = 0 // Static variables keep their values between function calls
    static int last_value = 0 // Last value starts at zero
    // The session key exists somewhere else as `session_key`

    return_array = {} // Encrypted values

    for unencrypted in data {
        encrypted = (unencrypted ^ session_key[index]) + last_value

        index = (index + 1) % session_key.length // Use the session key as a circular buffer

        return_array.append(encrypted)
        last_value = encrypted
    }

    return return_array
</code></pre><h4 id="implementations-12">Implementations</h4>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/bc10da51a44b368b64fe5491dc305287bb431e74/src/header_crypto/mod.rs#L106">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/90b9a7b43df4744f856e81e3efcf1de92bcb4ebf/src/gateway/PacketCrypto.h#L44">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/serverd/lib/session.ex#L56">Elixir (Shadowburn)</a></li>
</ul>
<h4 id="verification-values-12">Verification values</h4>
<ul>
<li><a href="verification_values/encryption/calculate_encrypt_values.txt">calculate_encrypt_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Session Key</th>
<th>Data (50 bytes)</th>
<th>Expected (50 bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
</tr>
</tbody>
</table>
<h3 id="decryption">Decryption</h3>
<p>Decryption does the opposite of encryption. So first the old encrypted value is subtracted from the encrypted value, before it is XORed with the session key.</p>
<p>The decryption is calculated as <code>x = (E - L) ^ S</code> where:</p>
<ul>
<li>
<p><code>x</code> is the unencrypted value, a byte of the opcode or size.</p>
</li>
<li>
<p><code>E</code> is the encrypted value, what is sent over the wire.</p>
</li>
<li>
<p><code>L</code> is the last encrypted value. This is <code>E</code> from the previous iteration.</p>
</li>
<li>
<p><code>S</code> is a byte of the session key, incrementing after every encryption.</p>
</li>
</ul>
<p>In pseudo code this would look like:</p>
<pre><code>function decrypt
    argument data: little endian array of length AL
    returns little endian array of length AL
    
    static int index = 0 // Static variables keep their values between function calls
    static int last_value = 0 // Last value starts at zero
    // The session key exists somewhere else as `session_key`

    return_array = {} // Unencrypted values

    for encrypted in data {
        unencrypted = (encrypted - previous_encrypted) ^ session_key[index]

        index = (index + 1) % session_key.length // Use the session key as a circular buffer

        last_value = encrypted
        return_array.append(unencrypted)
    }

    return return_array
</code></pre><h4 id="implementations-13">Implementations</h4>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/bc10da51a44b368b64fe5491dc305287bb431e74/src/header_crypto/mod.rs#L166">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/90b9a7b43df4744f856e81e3efcf1de92bcb4ebf/src/gateway/PacketCrypto.h#L58">C++ (Ember)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/serverd/lib/session.ex#L73">Elixir (Shadowburn)</a></li>
</ul>
<h4 id="verification-values-13">Verification values</h4>
<ul>
<li><a href="verification_values/encryption/calculate_decrypt_values.txt">calculate_decrypt_values.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Session Key</th>
<th>Data (50 bytes)</th>
<th>Expected (50 bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
</tr>
</tbody>
</table>
<h3 id="world-server-proof">World Server Proof</h3>
<p>After receiving the <a href="https://wowdev.wiki/CMSG_AUTH_SESSION">CMSG_AUTH_SESSION</a> message the server will have to verify that the client does indeed know the correct session key. This is done by having both the server and client use 32 bit (not byte) values as seeds in a hash with the session key.</p>
<p>The proof is calculated as <code>SHA1( username | 0 | client_seed | server_seed | session_key )</code>, where:</p>
<ul>
<li>
<p><code>username</code> is the <strong>username</strong> of the user attempting to connect.</p>
</li>
<li>
<p><code>0</code> is the literal value zero, taking up 4 bytes (32 bits, a standard <code>int</code>).</p>
</li>
<li>
<p><code>client_seed</code> is a random 4 byte value sent by the client.</p>
</li>
<li>
<p><code>server_seed</code> is a random 4 byte value generated by the server.</p>
</li>
<li>
<p><code>session_key</code> is the <strong>session key</strong> from the original authentication.</p>
</li>
</ul>
<p>Calculating the world proof in pseudo code would look like:</p>
<pre><code>function calculate_world_server_proof
    argument username: string
    argument client_seed: unsigned 32 byte value, converted to little endian bytes
    argument server_seed: unsigned 32 byte value, converted to little endian bytes
    argument session_key: little endian array of 40 bytes
    returns little endian array of 20 bytes

    zero = [0, 0, 0, 0] // Assume this is a 4 byte array of zeros

    return SHA1(username + zero + client_seed + server_seed + session_key)
</code></pre><h4 id="implementations-14">Implementations</h4>
<ul>
<li><a href="https://github.com/gtker/wow_srp/blob/761b040d9d7f18dcb760424eeaef15994f321116/src/srp_internal.rs#L260">Rust (wow_srp)</a></li>
<li><a href="https://github.com/EmberEmu/Ember/blob/b0dbeb3dc4230a18c7be38c2cedd712ef6e3cfd4/src/gateway/states/Authentication.cpp#L166">C++ (Ember)</a></li>
<li><a href="https://github.com/mangoszero/server/blob/e45aa74e0fa3a9677d90fc012b8161e1e9935742/src/game/Server/WorldSocket.cpp#L784">C++ (Mangos)</a></li>
<li><a href="https://gitlab.com/shadowburn/shadowburn/-/blob/ac905fabf56579b3bda6f16689c74f544da043e2/apps/serverd/lib/session.ex#L127">Elixir (Shadowburn)</a></li>
</ul>
<h4 id="verification-values-14">Verification values</h4>
<ul>
<li><a href="verification_values/encryption/calculate_world_server_proof.txt">calculate_world_server_proof.txt</a> contains the columns:</li>
</ul>
<table>
<thead>
<tr>
<th>Username</th>
<th>Session Key</th>
<th>Server Seed</th>
<th>Client Seed</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>Big Endian Hex</td>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
<td>Little Endian Hex</td>
</tr>
</tbody>
</table>
<h2 id="notes-on-uppercasing-username-and-password">Notes on uppercasing username and password</h2>
<p>The username and password are UTF-8 strings that are automatically uppercased by the client before being sent over the network.
This might present some issues with getting the correct name from the registration form and the client, more information is present at the <a href="https://docs.rs/wow_srp/0.2.0/wow_srp/normalized_string/index.html#background">wow_srp library documentation</a>.</p>
<h2 id="external-resources">External Resources</h2>
<ul>
<li>The <a href="https://shadowburn-project.org/2018/10/17/logging-in-with-vanilla.html">Shadowburn Project</a> has a guide on authenticating that focuses more on the networking and specific packets.</li>
<li>The <a href="https://wowdev.wiki/Login_Packet">WoWDev Wiki</a> has an overview of packets.</li>
<li><a href="https://www.wireshark.org/download.html">Wireshark</a> at version 3.5 or greater has support for parsing 1.12 packets through the <code>WOW</code> and <code>WOWW</code> protocols. You <strong>will</strong> need this if you&rsquo;re trying to debug a networked implementation.</li>
</ul>
]]></content></entry><entry><title type="html">Running assembly on the BL602 RISC-V microcontroller and directly controlling GPIO</title><link href="https://gtker.com/running-assembly-on-the-bl602-risc-v-microcontroller-and-directly-controlling-gpio/"/><id>https://gtker.com/running-assembly-on-the-bl602-risc-v-microcontroller-and-directly-controlling-gpio/</id><author><name>Gtker</name></author><published>2021-01-14T01:48:56+00:00</published><updated>2021-01-14T01:48:56+00:00</updated><content type="html"><![CDATA[<p>The Boufallo Lab BL602 is a 32 bit RISC-V microcontroller with support for 2.4 GHz WiFi and Bluetooth Low Energy 5.0.
It has an <a href="https://github.com/bouffalolab/bl_iot_sdk">official SDK</a>, however even the “Hello World example” includes a large amount of boilerplate.
This article will show how to manipulate the GPIO pins using assembly and no dependencies.</p>
<h2 id="git-repository">Git repository</h2>
<p>The full assembly and a makefile can be found <a href="https://github.com/gtker/bl602-assembly">in this Github repository</a>.</p>
<h2 id="background">Background</h2>
<p>As seen on the <a href="https://github.com/pine64/bl602-docs/blob/4c72881b6b4e1aa2ff5cdc5991de46e07fe39160/mirrored/Pine64%20BL602%20EVB%20Schematic%20ver%201.1.pdf">Pine64 BL602 EVB ver 1.1 schematics</a> <code>LED1</code> is three separate diodes controlled through <code>GPIO17</code> (Red), <code>GPIO14</code> (Green) and <code>GPIO11</code> (Blue).
<code>LED1</code> is not to be confused with <code>LED2</code> which just lights up red when the board is plugged in.</p>
<p><a href="https://github.com/pine64/bl602-docs/tree/42b5581e37b8c21ed6320c43392c6c93e0803ab3">Page 18 of the BL602 reference manual</a> shows that the XIP (eXecute In Place) memory starts at address <code>0x23000000</code>.
<code>blflash</code> <a href="https://github.com/spacemeowx2/blflash/releases/tag/v0.3.0">version 0.3.0</a> writes binary files to address <code>0x23000000</code> by default so no linker scripts are necessary.</p>
<h2 id="gpio-on-the-bl602">GPIO on the BL602</h2>
<p>GPIO on the BL602 can be controlled through several pre defined registers.
<a href="https://github.com/pine64/bl602-docs/tree/42b5581e37b8c21ed6320c43392c6c93e0803ab3">Page 24 to 29 of the BL602 reference manual</a> describes the general approach.</p>
<p>In order to initialize and control the GPIO pins the following must be done:</p>
<ol>
<li>The GPIO pin function and resistor type must be set. The exact register depends on the GPIO pin.</li>
<li>The relevant bit in the GPIO Output Enable register (<code>GPIO_CFGCTL34_OFFSET</code>) must be set.</li>
<li>The relevant bit in the GPIO Output register (<code>GPIO_CFGCTL32_OFFSET</code>) must be set.</li>
</ol>
<p>The locations are described in the <a href="https://github.com/pine64/bl602-docs/tree/42b5581e37b8c21ed6320c43392c6c93e0803ab3/hardware_notes/registers/glb">unofficial hardware notes</a>.</p>
<h2 id="exact-plan-for-gpio11">Exact plan for <code>GPIO11</code></h2>
<p>The Global Register (GLB) is located at address <code>0x40000000</code>.</p>
<p><a href="https://github.com/pine64/bl602-docs/tree/42b5581e37b8c21ed6320c43392c6c93e0803ab3">Page 28 and 29 of the BL602 reference manual</a> list <code>GPIO_CFGCTL5</code> as the register for configuring <code>GPIO10</code> and <code>GPIO11</code>.
The register overview on page 36 describes the 16 most significant bits as being used for <code>GPIO11</code> and the 16 least significant bits as being used for <code>GPIO10</code>.
The two parts of the register have the same layout, <code>GPIO11</code> is just bitshifted left 16:</p>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td></td>
<td></td>
<td>PD</td>
<td>PU</td>
<td>DRV</td>
<td>DRV</td>
<td>SMT</td>
<td>IE</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Where reserved bits are blank and following symbols are used:</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>Function select</td>
</tr>
<tr>
<td>PD</td>
<td>Pull-Down Resistor</td>
</tr>
<tr>
<td>PU</td>
<td>Pull-Up Resistor</td>
</tr>
<tr>
<td>DRV</td>
<td>Driving control</td>
</tr>
<tr>
<td>SMT</td>
<td>Schmitt trigger</td>
</tr>
<tr>
<td>IE</td>
<td>Input enabled</td>
</tr>
</tbody>
</table>
<p>The function select should be set to 11 (0b1011) in order to choose Software GPIO, and the pull up resistor should be enabled.
This means we will have to write the value <code>0b0000101100100000 &lt;&lt; 16</code> to the <code>GPIO_CFGCTL5</code> register at address <code>0x40000144</code>.
The LEDs require sinking current into the GPIO pins, so it should be off until you explicitly pull it <code>LOW</code>.
If the pulldown resistor was enabled the LED would be on by default.</p>
<p>Next, the 11th bit of the Output Enable register (<code>GPIO_CFGCTL34_OFFSET</code>) at address <code>0x40000190</code> must be set.
Bit shifting <code>1 &lt;&lt; 11</code> will work.</p>
<p>Finally the 11th bit of the Output register (<code>GPIO_CFGCTL32_OFFSET</code>) at address <code>0x40000188</code> must be set <code>LOW</code>.</p>
<h2 id="c-and-assembly-examples">C and assembly examples</h2>
<p>The C code is provided for reference only and has not been tested.
In C we would do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> GPIO_CFGCTL5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000114</span>;
    <span style="color:#66d9ef">int</span> GPIO_BITSET_CFGCTL5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>b0000101100100000 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>;
    <span style="color:#f92672">*</span>GPIO_CFGCTL5 <span style="color:#f92672">=</span> GPIO_BITSET_CFGCTL5;

    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> GPIO_CFGCTL32 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000188</span>;
    <span style="color:#66d9ef">int</span> GPIO_BITSET_OUTPUT_ENABLE <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">11</span>;
    <span style="color:#f92672">*</span>GPIO_CFGCTL32 <span style="color:#f92672">=</span> GPIO_BITSET_OUTPUT_ENABLE;

    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> GPIO_CFGCTL34 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000190</span>;
    <span style="color:#66d9ef">int</span> GPIO_BITSET_OUTPUT <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">11</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        <span style="color:#75715e">// Trap execution to prevent weird results.
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// Continuously set GPIO status to ensure it isn&#39;t
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// quickly toggled off for some reason.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>GPIO_CFGCTL34 <span style="color:#f92672">=</span> GPIO_BITSET_OUTPUT;
    }
}
</code></pre></div><p>In assembly we do almost the same, except we use the GLB as a reference point and compute relative addresses using the <code>sw</code> instruction.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># RM = BL602 Reference Manual 1.2. See the Pine64 bl602-docs repo.
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># Global Register base address. Page 23 of the RM.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.set</span> <span style="color:#66d9ef">GLB_BASE</span>, <span style="color:#ae81ff">0x40000000</span>
<span style="color:#75715e"># GPIO 10 and 11 configuration. Page 36 of the RM.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.set</span> <span style="color:#66d9ef">GPIO_CFGCTL5_OFFSET</span>, <span style="color:#ae81ff">0x114</span>

<span style="color:#75715e"># GPIO Output Register. Not described in RM.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.set</span> <span style="color:#66d9ef">GPIO_CFGCTL32_OFFSET</span>, <span style="color:#ae81ff">0x188</span>

<span style="color:#75715e"># GPIO Output Enable register. Not described in RM.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.set</span> <span style="color:#66d9ef">GPIO_CFGCTL34_OFFSET</span>, <span style="color:#ae81ff">0x190</span>

<span style="color:#75715e"># Bitset to set GP11FUNC to 11 (SWGPIO), Pullup to 1
</span><span style="color:#75715e"># and rest to zero. Page 36 of the RM.
</span><span style="color:#75715e"># GPIO11 are the 16 highest bits.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.set</span> <span style="color:#66d9ef">GPIO_BITSET_CFGCTL5</span>, <span style="color:#ae81ff">0</span><span style="color:#66d9ef">b0000101100010000</span> <span style="color:#960050;background-color:#1e0010">&lt;&lt;</span> <span style="color:#ae81ff">16</span>

<span style="color:#75715e"># Bitset for Output and Output Enable register. 11th bit = GPIO11.
</span><span style="color:#75715e"># High enables the output.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.set</span> <span style="color:#66d9ef">GPIO_BITSET_OUTPUT_ENABLE</span>, <span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">&lt;&lt;</span> <span style="color:#ae81ff">11</span>

<span style="color:#75715e"># Low enables the LED because the GPIO sinks current.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.set</span> <span style="color:#66d9ef">GPIO_BITSET_OUTPUT</span>, <span style="color:#ae81ff">0</span> <span style="color:#960050;background-color:#1e0010">&lt;&lt;</span> <span style="color:#ae81ff">11</span>

<span style="color:#a6e22e">.section</span> <span style="color:#66d9ef">.text</span>

main:
    <span style="color:#75715e"># la = Load Address
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Can be used to compute an offset from address, 
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># but not used here.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Load GLB_BASE pointer into &#39;temporary1&#39;
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># int* t1 = (int*) GLB_BASE;
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">la</span> <span style="color:#66d9ef">t1</span>, <span style="color:#66d9ef">GLB_BASE</span>

    <span style="color:#75715e"># Load bitset for config control 5 into &#39;temporary2&#39;
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># int t2 = GPIO_BITSET_CFGCTL5;
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">la</span> <span style="color:#66d9ef">t2</span>, <span style="color:#66d9ef">GPIO_BITSET_CFGCTL5</span>

    <span style="color:#75715e"># sw = Store Word (32 bits)
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Store &#39;temporary2&#39; in GLB_BASE pointer, plus the
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># GPIO10/GPIO11 register offset.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># *(t1 + GPIO_CFGCTL5_OFFSET) = t2;
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sw</span> <span style="color:#66d9ef">t2</span>, <span style="color:#66d9ef">GPIO_CFGCTL5_OFFSET</span>(<span style="color:#66d9ef">t1</span>)

    <span style="color:#75715e"># Load bitset for enabling GPIO11 into &#39;temporary2&#39;.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># t2 = GPIO_BITSET_OUTPUT_ENABLE; 
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">la</span> <span style="color:#66d9ef">t2</span>, <span style="color:#66d9ef">GPIO_BITSET_OUTPUT_ENABLE</span>

    <span style="color:#75715e"># Store &#39;temporary2&#39; in GLB_BASE pointer, plus the
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Output Enable register offset.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># *(t1 + GPIO_CFGCTL34_OFFSET) = t2;
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sw</span> <span style="color:#66d9ef">t2</span>, <span style="color:#66d9ef">GPIO_CFGCTL34_OFFSET</span>(<span style="color:#66d9ef">t1</span>)

    <span style="color:#75715e"># t2 = GPIO_BITSET_OUTPUT;
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># The bitset for output enable should not be used for
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># output.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">la</span> <span style="color:#66d9ef">t2</span>, <span style="color:#66d9ef">GPIO_BITSET_OUTPUT</span>

<span style="color:#75715e"># Loop label.
</span><span style="color:#75715e"></span>loop:

    <span style="color:#75715e"># Store &#39;temporary2&#39; in GLB_BASE pointer, plus the
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Out register offset.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># This is the bit you would switch in order to blink
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># LED.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># *(t1 + GPIO_CFGCTL32_OFFSET) = t2;
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sw</span> <span style="color:#66d9ef">t2</span>, <span style="color:#66d9ef">GPIO_CFGCTL32_OFFSET</span>(<span style="color:#66d9ef">t1</span>)

    <span style="color:#75715e"># Unconditionally Jump to loop.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># goto loop;
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">loop</span>
</code></pre></div><h2 id="building-linking-and-flashing">Building, linking and flashing</h2>
<p>The general approach is to:</p>
<ol>
<li>build the assembly with <code>as</code>,</li>
<li>link it with <code>ld</code>,</li>
<li>convert the ELF file to binary with <code>objcopy</code>,</li>
<li>flash it to the board with <code>blflash</code>.</li>
</ol>
<p>The <a href="https://github.com/pine64/bl_iot_sdk">Pine64</a> version of the repository include the necessary <code>riscv64-unknown-elf</code> versions of every tool mentioned above (in <code>toolchain/riscv/Linux/bin</code>), except for <code>blflash</code> which can be found <a href="https://github.com/spacemeowx2/blflash">at the Github repository</a>.</p>
<p>Exact commands can be found in the <code>Makefile</code> at the <a href="https://github.com/gtker/bl602-assembly">git repository</a>.</p>
]]></content></entry><entry><title type="html">Regulating Unwanted Smart Device Traffic Using PiHole and Edgerouter X</title><link href="https://gtker.com/regulating-unwanted-smart-device-traffic-using-pihole-and-edgerouter-x/"/><id>https://gtker.com/regulating-unwanted-smart-device-traffic-using-pihole-and-edgerouter-x/</id><author><name>Gtker</name></author><published>2020-12-06T21:30:44+00:00</published><updated>2020-12-06T21:30:44+00:00</updated><content type="html"><![CDATA[<p>98% of smart assistants and 72% of smart TVs use hard coded DNS servers. <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>
The inclusion of ads on smart TVs even by well known brands like <a href="https://www.rtings.com/tv/tests/ads-in-smart-tv">Samsung, Sony and LG</a> (<a href="https://web.archive.org/web/20201112014902/https://www.rtings.com/tv/tests/ads-in-smart-tv">archive</a>) significantly increases the need for forced DNS adblocking of devices that deliberately ignore DHCP provided DNS.
A Pihole DNS by itself can prevent ads from devices that are well behaved, but misbehaving devices will have to be forced by either a firewall or router.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>It is assumed that a working Pihole newer than version 5 is set up at <code>192.168.1.11</code> with an accessible admin interface at <code>http://192.168.1.11</code> and that a working Edgerouter X is set up at <code>192.168.1.1</code> with an accessible admin interface at <code>https://192.168.1.1</code>.
It might be necessary to downgrade the Edgerouter X connection to HTTP depending on settings.</p>
<p>The device to be regulated is assumed to be located at <code>192.168.1.60</code>, and it will be referred to as &ldquo;the TV&rdquo; from now on.
It is assumed that the TV has a reason for being on the network, since the most effective way of preventing something from communicating through a network is by not connecting it to the network.
The tutorial below assumes that a single service must be used through a smart TV, and that everything else must be blocked.</p>
<p>Be aware that <code>192.168.**1**.0</code> and <code>192.168.**0**.0</code> are two popular address spaces for home networks that look alike at a glance.
Make sure that you&rsquo;re using the correct network for you, despite what the examples say.</p>
<h2 id="dns-blocking-on-pihole">DNS blocking on Pihole</h2>
<p>The images are from version 5.1.1 of the Pihole Web Interface.</p>
<p>Log in to the Pihole Web Interface at <code>http://192.168.1.11/admin</code>.</p>
<p>Go to &ldquo;Groups&rdquo; under &ldquo;Group Management&rdquo; in the left menu as seen in figure 1.
<figure>
    <img src="pihole/navigation-menu.png" alt="Navigation Menu on the left side of the Pihole Web Interface."/>
    <figcaption><b>Figure 1:</b> Navigation Menu on the left side of the Pihole Web Interface.
        <br>
        
</figure>
</p>
<p>Add a new group called &ldquo;TV&rdquo; and put any comments in the &ldquo;Description&rdquo; field as seen in figure 2.</p>
<figure>
    <img src="pihole/new-group.png" alt="Adding a new group named &#39;TV&#39;. Only &#39;Name&#39; is relevant, &#39;Description&#39; is only documentation."/>
    <figcaption><b>Figure 2:</b> Adding a new group named &#39;TV&#39;. Only &#39;Name&#39; is relevant, &#39;Description&#39; is only documentation.
        <br>
        
</figure>

<p>Go to &ldquo;Clients&rdquo; through the same menu as figure 1.</p>
<p>Add the address of the TV as seen in figure 3 and include a short description.
It is recommended to identify the address in some way, even if it&rsquo;s just &ldquo;TV&rdquo;, since few people can correctly remember the IP-addresses of every device on their LAN.
If the address of the TV is not found in the dropdown you can manually insert it using the &ldquo;Custom, specified below&rdquo; option.</p>
<figure>
    <img src="pihole/add-new-client.png" alt="Adding a new client by using the &#39;Custom, specified below...&#39; option and manually inputting the address."/>
    <figcaption><b>Figure 3:</b> Adding a new client by using the &#39;Custom, specified below...&#39; option and manually inputting the address.
        <br>
        
</figure>

<p>Assign the new client to the group made in figure 2 and remove it from the &ldquo;Default&rdquo; group as seen in figure 4.</p>
<figure>
    <img src="pihole/client-to-group.png" alt="Adding a new client to the &#39;TV&#39; group and removing it from the &#39;Default&#39; group."/>
    <figcaption><b>Figure 4:</b> Adding a new client to the &#39;TV&#39; group and removing it from the &#39;Default&#39; group.
        <br>
        
</figure>

<p>Next, go to &ldquo;Domains&rdquo; through the same menu as figure 1.</p>
<p>Add <code>[a-z]*|[0-9]*|\.</code> as a &ldquo;Domain&rdquo;, and <code>Block all domains.</code> as the &ldquo;Comment&rdquo; as seen in figure 5, and click &ldquo;Add to Blacklist&rdquo; just below.
Remember to check the &ldquo;Add domain as wildcard.
This will block all domains.</p>
<figure>
    <img src="pihole/block-all-domains.png" alt="Adding the regular expression &#39;[a-z]*|[0-9]*|\.&#39; to &#39;Domain&#39; in order to block all domains. Make sure to check &#39;Add domain as wildcard&#39;. The &#39;Add to Blacklist&#39; button is found just below this."/>
    <figcaption><b>Figure 5:</b> Adding the regular expression &#39;[a-z]*|[0-9]*|\.&#39; to &#39;Domain&#39; in order to block all domains. Make sure to check &#39;Add domain as wildcard&#39;. The &#39;Add to Blacklist&#39; button is found just below this.
        <br>
        
</figure>

<p>Scroll down until you find the filter you added in figure 5.</p>
<p>Ensure that the <code>[a-z]*|[0-9]*|\.</code> filter you just added is a &ldquo;Regex blacklist&rdquo;, &ldquo;Enabled&rdquo; and applied only to the group you created in figure 2.
It <strong>must</strong> not be applied to the &ldquo;Default&rdquo; group, otherwise all domains will be blocked on all devices.</p>
<figure>
    <img src="pihole/apply-all-to-tv.png" alt="List of blocklists on the Pihole. Ensure that the recently added filter is listed as &#39;Regex  blacklist&#39;, &#39;Enabled&#39; and in the &#39;TV&#39; group but not in the &#39;Default&#39; group."/>
    <figcaption><b>Figure 6:</b> List of blocklists on the Pihole. Ensure that the recently added filter is listed as &#39;Regex  blacklist&#39;, &#39;Enabled&#39; and in the &#39;TV&#39; group but not in the &#39;Default&#39; group.
        <br>
        
</figure>

<p>All DNS queries are now blocked on the TV, and you must manually approve individual services that you require.
To find out whether you need to set up your Edgerouter X for DNS redirection you should turn on your TV and check if network features are completely broken.
If they are, your TV respects the DHCP provided DNS, and if they are not you either have not set your Pihole as the DNS in your DHCP settings or your TV does not respect DHCP settings.</p>
<p>You will now need to approve the necessary domains for your service to work.
After trying to access the required service on your TV, go into the &ldquo;Query Log&rdquo; under &ldquo;Long-term data&rdquo; in the left menu.
Select the date and time range &ldquo;Today&rdquo;.
Scroll down and narrow the search to your TV by entering <code>192.168.1.60</code> in the &ldquo;Search&rdquo; field like in figure 7.
The exact domain depends on the service you&rsquo;re trying to allow.
If you&rsquo;re in doubt, do a search for the domain in question and read up on what it does.
It might be necessary to do this over several iterations, as services on the TV might require different domains at several points.</p>
<figure>
    <img src="pihole/approve-domains.png" alt="Approving domains for the TV. The search has been used to narrow the list to only the TV. Domains can be allowed with the &#39;Whitelist&#39; button on the right. A records are IPv4 and AAAA records are IPv6."/>
    <figcaption><b>Figure 7:</b> Approving domains for the TV. The search has been used to narrow the list to only the TV. Domains can be allowed with the &#39;Whitelist&#39; button on the right. A records are IPv4 and AAAA records are IPv6.
        <br>
        
</figure>

<h2 id="dns-redirection-on-edgerouter-x">DNS Redirection on Edgerouter X</h2>
<p>If your TV does not use the DHCP DNS by default, you should set up DNS redirection on a firewall or router.</p>
<p>Log into the web interface of your Edgerouter X and click the &ldquo;Firewall/NAT&rdquo; tab as shown in figure 8.</p>
<figure>
    <img src="edgerouterx/firewall.png" alt="Firewall/NAT tab on the Edgerouter X."/>
    <figcaption><b>Figure 8:</b> Firewall/NAT tab on the Edgerouter X.
        <br>
        
</figure>

<p>Next, click the &ldquo;NAT&rdquo; tab as shown in figure 9.</p>
<figure>
    <img src="edgerouterx/nat.png" alt="NAT tab in the Firewall/NAT tab."/>
    <figcaption><b>Figure 9:</b> NAT tab in the Firewall/NAT tab.
        <br>
        
</figure>

<p>Click the &ldquo;Add Source NAT Rule&rdquo; button as shown in figure 10.</p>
<figure>
    <img src="edgerouterx/add-source-nat.png" alt="Adding new source rule."/>
    <figcaption><b>Figure 10:</b> Adding new source rule.
        <br>
        
</figure>

<p>Set up the rule as shown in figure 11, paying special attention to the below fields:</p>
<ol>
<li><strong>Description:</strong> Name of the rule.</li>
<li><strong>Outbound Interface:</strong> If you used the Basic Wizard to set up the Edgerouter X, you should set this to <code>switch0</code>.</li>
<li><strong>Src Address:</strong> The addresses that this rule should apply to. Since my DHCP range is <code>192.168.1.100</code> to <code>192.168.1.254</code> that&rsquo;s what I&rsquo;m putting in. If you only want to apply to the TV, set it to <code>192.168.1.1.60</code>.</li>
<li><strong>Src Port:</strong> Leave blank.</li>
<li><strong>Dest Address:</strong> Set to the address of your Pihole. Set to <code>192.168.1.11</code>.</li>
<li><strong>Dest Port:</strong> Set to <code>53</code>.</li>
</ol>
<figure>
    <img src="edgerouterx/source-nat-settings.png" alt="Screen for creating new source NAT rules."/>
    <figcaption><b>Figure 11:</b> Screen for creating new source NAT rules.
        <br>
        
</figure>

<p>Click save on figure 11 and then &ldquo;Add Destination NAT Rule&rdquo; just below the button in figure 10.</p>
<p>Set up the rule as shown in figure 12, paying special attention to the below fields:</p>
<ol>
<li><strong>Description:</strong> Name of the rule.</li>
<li><strong>Inbound Interface:</strong> Same as in figure 11.</li>
<li><strong>Translations Address:</strong> Set to the address of your Pihole, <code>192.168.1.11</code>.</li>
<li><strong>Translations Port:</strong> Set to <code>53</code>.</li>
<li><strong>Src Address:</strong> Set to addresses you want to redirect DNS for. For everything except your pihole set to <code>!192.168.1.11</code>, noticing the <code>!</code> which means <code>NOT</code>.</li>
<li><strong>Src Port:</strong> Leave blank.</li>
<li><strong>Dest Address:</strong> Set to the same as Src Address.</li>
<li><strong>Dest Port:</strong> Set to 53.</li>
</ol>
<figure>
    <img src="edgerouterx/destination-nat-settings.png" alt="Screen for creating new source NAT rules."/>
    <figcaption><b>Figure 12:</b> Screen for creating new source NAT rules.
        <br>
        
</figure>

<h2 id="testing">Testing</h2>
<p>In order to test your solution you should, on Windows or Linux, run <code>nslookup [blocked domain] 8.8.8.8</code> and see that you get a <code>0.0.0.0</code> result back.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>M. H. Mazhar and Z. Shafiq, &ldquo;<a href="https://arxiv.org/pdf/2001.08288.pdf">Characterizing Smart Home IoT Traffic in the Wild</a>&rdquo;, 2020 IEEE/ACM Fifth International Conference on Internet-of-Things Design and Implementation (IoTDI), pp. 2, Mar. 2020. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Improved way of rendering TeX math in Hugo</title><link href="https://gtker.com/improved-way-of-rendering-tex-math-in-hugo/"/><id>https://gtker.com/improved-way-of-rendering-tex-math-in-hugo/</id><author><name>Gtker</name></author><published>2020-11-29T00:09:00+00:00</published><updated>2020-11-29T00:09:00+00:00</updated><content type="html"><![CDATA[<p><a href="https://latkin.org/blog/about/">Lincoln Atkinson</a> wrote a post about <a href="https://latkin.org/blog/2016/08/07/better-tex-math-typesetting-in-hugo/">TeX math typesetting in Hugo</a> (<a href="https://web.archive.org/web/20201108141222/https://latkin.org/blog/2016/08/07/better-tex-math-typesetting-in-hugo/">archive</a>) where he described a solution that could do TeX math typesetting with and without Javascript enabled.</p>
<p>I have improved slightly upon his method, creating a simple Python script to download the equation images prior to publication and serving them from the local web server.</p>
<h2 id="why">Why?</h2>
<p>The primary reason was that I wanted a missing <code>noscript</code> equation to be an error at compile time instead of just a dead link.
When going to the <a href="https://latex.codecogs.com/">codecogs</a> website at the time of writing, I see the following in a little box:</p>
<pre><code>Licence Details
Registered use:     CLOUD
Expiration date:    31-12-2020
</code></pre><p>What does that mean?
I have no idea.
It might mean that service transistions to a new backend at the start of 2021, or it might mean that the service completely shuts down.</p>
<h2 id="how">How?</h2>
<p>Lincoln created a shortcode<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> that inserts an image with <code>src=latex.codecogs.com/gif.latex?</code> followed by the equation to render, ending with <code> title=</code> (the <code>&quot;</code> are removed by Hugo).</p>
<p>Knowing this it is possible to create a script that finds all instances of the <code>codecogs.com</code> sources, downloads the equation as a file and replaces the <code>src=</code> attribute with the local file.</p>
<p>The benefits of this approach is that the noscript equations still work before the script is run, it&rsquo;s just fetched from <code>codecogs.com</code> instead of locally.</p>
<h2 id="script">Script</h2>
<p>Running the script in the directory that contains the <code>public</code> folder will download equations, place them next to the <code>.html</code> file and replace the <code>src=</code> attribute.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/user/bin/env python3</span>
<span style="color:#f92672">from</span> pathlib <span style="color:#f92672">import</span> Path
<span style="color:#f92672">import</span> requests
<span style="color:#f92672">import</span> urllib

EXTENSION <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;svg&#34;</span>
LATEX_URL <span style="color:#f92672">=</span> f<span style="color:#e6db74">&#34;https://latex.codecogs.com/{EXTENSION}.latex?&#34;</span>
LATEX_INLINE <span style="color:#f92672">=</span> f<span style="color:#e6db74">&#34;https://latex.codecogs.com/{EXTENSION}.latex?\inline&amp;space;&#34;</span>

<span style="color:#66d9ef">for</span> path <span style="color:#f92672">in</span> Path(<span style="color:#e6db74">&#39;public&#39;</span>)<span style="color:#f92672">.</span>rglob(<span style="color:#e6db74">&#39;*.html&#39;</span>):
    contents <span style="color:#f92672">=</span> Path(path)<span style="color:#f92672">.</span>read_text();

    <span style="color:#66d9ef">while</span> (LATEX_INLINE <span style="color:#f92672">in</span> contents) <span style="color:#f92672">or</span> (LATEX_URL <span style="color:#f92672">in</span> contents):
        latex_url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> LATEX_INLINE <span style="color:#f92672">in</span> contents:
            latex_url <span style="color:#f92672">=</span> LATEX_INLINE
        <span style="color:#66d9ef">elif</span> LATEX_URL <span style="color:#f92672">in</span> contents:
            latex_url <span style="color:#f92672">=</span> LATEX_URL
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">continue</span>

        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;PATH: &#34;</span> <span style="color:#f92672">+</span> str(path))

        index <span style="color:#f92672">=</span> contents<span style="color:#f92672">.</span>find(latex_url)
        end <span style="color:#f92672">=</span> contents<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34; title=&#34;</span>, index)
        equation <span style="color:#f92672">=</span> contents[index <span style="color:#f92672">+</span> len(latex_url):end]
        url <span style="color:#f92672">=</span> contents[index:end]

        f <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(url)<span style="color:#f92672">.</span>content
        <span style="color:#66d9ef">with</span> open(path<span style="color:#f92672">.</span>parent<span style="color:#f92672">.</span>joinpath(equation <span style="color:#f92672">+</span> f<span style="color:#e6db74">&#34;.{EXTENSION}&#34;</span>), <span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> w:
            w<span style="color:#f92672">.</span>write(f)

        <span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Replacing {url} with {urllib.parse.quote(equation)}.{EXTENSION}&#34;</span>)
        contents <span style="color:#f92672">=</span> contents<span style="color:#f92672">.</span>replace(url, urllib<span style="color:#f92672">.</span>parse<span style="color:#f92672">.</span>quote(equation) <span style="color:#f92672">+</span> f<span style="color:#e6db74">&#34;.{EXTENSION}&#34;</span>)

    <span style="color:#66d9ef">with</span> open(path, <span style="color:#e6db74">&#39;w&#39;</span>) <span style="color:#66d9ef">as</span> w:
        w<span style="color:#f92672">.</span>write(contents)
</code></pre></div><h2 id="future-work">Future work</h2>
<p>Ideally the equations would be done entirely at compile time without external dependencies.
Currently it does not seem possible to do entirely in HTML, since the math requires some fonts that are not installed by default on most platforms.
A LaTeX to SVG tool could be used, but would break the <code>hugo serve</code> tool since it does not seem possible to insert arbitrary commands in that process.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Think of it like a function for Hugo that inserts text and can take parameters. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry></feed>